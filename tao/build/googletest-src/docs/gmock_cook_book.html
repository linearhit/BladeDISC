

<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gMock Cookbook &mdash; BladeDISC 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

</head>

<body>
    <header>
        <div class="container">
            <a class="site-nav-toggle hidden-lg-up"><i class="icon-menu"></i></a>
            <a class="site-title" href="../../../../index.html">
                BladeDISC
            </a>
        </div>
    </header>


<div class="breadcrumbs-outer hidden-xs-down">
    <div class="container">
        















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a></li>
        
      <li>gMock Cookbook</li>
    
    
      <li class="breadcrumbs-aside">
        
            
            <a href="../../../../_sources/tao/build/googletest-src/docs/gmock_cook_book.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>
</div>
    </div>
</div>
    <div class="main-outer">
        <div class="container">
            <div class="row">
                <div class="col-12 col-lg-3 site-nav">
                    
<div role="search">
    <form class="search" action="../../../../search.html" method="get">
        <div class="icon-input">
            <input type="text" name="q" placeholder="Search" />
            <span class="icon-search"></span>
        </div>
        <input type="submit" value="Go" class="d-hidden" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
    </form>
</div>
                    <div class="site-nav-tree">
                        
                            
                            
                                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../README_.html">BladeDISC Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#api-quickview">API QuickView</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#for-pytorch-users">For PyTorch Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#setup-and-examples">Setup and Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#publications">Publications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#tutorials-and-documents-for-developers">Tutorials and Documents for Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#how-to-contribute">How to Contribute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#faq">FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../README_.html#contact-us">Contact Us</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/install_with_docker.html">Install with Docker</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/install_with_docker.html#download-a-bladedisc-docker-image">Download a BladeDISC Docker Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/install_with_docker.html#start-a-docker-container">Start a Docker Container</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/build_from_source.html">Build from Source</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/build_from_source.html#prerequisite">Prerequisite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/build_from_source.html#checkout-the-source">Checkout the Source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/build_from_source.html#building-bladedisc-for-tensorflow-users">Building BladeDISC for TensorFlow Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/build_from_source.html#building-bladedisc-for-pytorch-users">Building BladeDISC for PyTorch Users</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/quickstart.html">Quickstart for TensorFlow/PyTorch users</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/quickstart.html#quickstart-for-tensorflow-users">Quickstart for TensorFlow Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/quickstart.html#quickstart-for-pytorch-users">Quickstart for PyTorch Users</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/contribution.html">How to Contribute</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/contribution.html#local-development-environment">Local Development Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/contribution.html#submit-a-pull-request-to-bladedisc">Submit a Pull Request to BladeDISC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/developers/index.html">Documentation for Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/developers/pass_pipeline.html">Tutorial: A Walkthough of the BladeDISC Pass Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/developers/runtime_abstraction_layer.html">Runtime Abstraction Layer Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/developers/bladedisc_torch_overview.html">BladeDISC Torch Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/developers/torch_add_a_new_converter.html">Tutorial: How to add the support of a new Torch Op</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docs/tutorials/index.html">Tutorials on Example Use Cases</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/tutorials/tensorflow_inference_and_training.html">Use case of TensorFlow Inference and Training</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docs/tutorials/torch_bert_inference.html">Use case of PyTorch Inference</a></li>
</ul>
</li>
</ul>

                            
                        
                    </div>
                </div>
                <div class="col-12 col-lg-9">
                    <div class="document">
                        
                            
  <div class="section" id="gmock-cookbook">
<h1>gMock Cookbook<a class="headerlink" href="#gmock-cookbook" title="Permalink to this headline">¶</a></h1>
<p>You can find recipes for using gMock here. If you haven’t yet, please read
<a class="reference internal" href="gmock_for_dummies.html"><span class="doc">the dummy guide</span></a> first to make sure you understand the
basics.</p>
<p>{: .callout .note}
<strong>Note:</strong> gMock lives in the <code class="docutils literal notranslate"><span class="pre">testing</span></code> name space. For readability, it is
recommended to write <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">::testing::Foo;</span></code> once in your file before using the
name <code class="docutils literal notranslate"><span class="pre">Foo</span></code> defined by gMock. We omit such <code class="docutils literal notranslate"><span class="pre">using</span></code> statements in this section for
brevity, but you should do it in your own code.</p>
<div class="section" id="creating-mock-classes">
<h2>Creating Mock Classes<a class="headerlink" href="#creating-mock-classes" title="Permalink to this headline">¶</a></h2>
<p>Mock classes are defined as normal classes, using the <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> macro to
generate mocked methods. The macro gets 3 or 4 parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyMock</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">ReturnType</span><span class="p">,</span> <span class="n">MethodName</span><span class="p">,</span> <span class="p">(</span><span class="n">Args</span><span class="p">...));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">ReturnType</span><span class="p">,</span> <span class="n">MethodName</span><span class="p">,</span> <span class="p">(</span><span class="n">Args</span><span class="p">...),</span> <span class="p">(</span><span class="n">Specs</span><span class="p">...));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The first 3 parameters are simply the method declaration, split into 3 parts.
The 4th parameter accepts a closed list of qualifiers, which affect the
generated method:</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">const</span></code></strong> - Makes the mocked method a <code class="docutils literal notranslate"><span class="pre">const</span></code> method. Required if
overriding a <code class="docutils literal notranslate"><span class="pre">const</span></code> method.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">override</span></code></strong> - Marks the method with <code class="docutils literal notranslate"><span class="pre">override</span></code>. Recommended if overriding
a <code class="docutils literal notranslate"><span class="pre">virtual</span></code> method.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">noexcept</span></code></strong> - Marks the method with <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. Required if overriding a
<code class="docutils literal notranslate"><span class="pre">noexcept</span></code> method.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Calltype(...)</span></code></strong> - Sets the call type for the method (e.g. to
<code class="docutils literal notranslate"><span class="pre">STDMETHODCALLTYPE</span></code>), useful in Windows.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">ref(...)</span></code></strong> - Marks the method with the reference qualification
specified. Required if overriding a method that has reference
qualifications. Eg <code class="docutils literal notranslate"><span class="pre">ref(&amp;)</span></code> or <code class="docutils literal notranslate"><span class="pre">ref(&amp;&amp;)</span></code>.</p></li>
</ul>
<div class="section" id="dealing-with-unprotected-commas">
<h3>Dealing with unprotected commas<a class="headerlink" href="#dealing-with-unprotected-commas" title="Permalink to this headline">¶</a></h3>
<p>Unprotected commas, i.e. commas which are not surrounded by parentheses, prevent
<code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> from parsing its arguments correctly:</p>
<p>{: .bad}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">GetPair</span><span class="p">,</span> <span class="p">());</span>  <span class="c1">// Won&#39;t compile!</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">CheckMap</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">));</span>  <span class="c1">// Won&#39;t compile!</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Solution 1 - wrap with parentheses:</p>
<p>{: .good}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">GetPair</span><span class="p">,</span> <span class="p">());</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">CheckMap</span><span class="p">,</span> <span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">),</span> <span class="kt">bool</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that wrapping a return or argument type with parentheses is, in general,
invalid C++. <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> removes the parentheses.</p>
<p>Solution 2 - define an alias:</p>
<p>{: .good}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">BoolAndInt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">BoolAndInt</span><span class="p">,</span> <span class="n">GetPair</span><span class="p">,</span> <span class="p">());</span>
  <span class="k">using</span> <span class="n">MapIntDouble</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">CheckMap</span><span class="p">,</span> <span class="p">(</span><span class="n">MapIntDouble</span><span class="p">,</span> <span class="kt">bool</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-private-or-protected-methods">
<h3>Mocking Private or Protected Methods<a class="headerlink" href="#mocking-private-or-protected-methods" title="Permalink to this headline">¶</a></h3>
<p>You must always put a mock method definition (<code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>) in a <code class="docutils literal notranslate"><span class="pre">public:</span></code>
section of the mock class, regardless of the method being mocked being <code class="docutils literal notranslate"><span class="pre">public</span></code>,
<code class="docutils literal notranslate"><span class="pre">protected</span></code>, or <code class="docutils literal notranslate"><span class="pre">private</span></code> in the base class. This allows <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> and
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> to reference the mock function from outside of the mock class.
(Yes, C++ allows a subclass to change the access level of a virtual function in
the base class.) Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Transform</span><span class="p">(</span><span class="n">Gadget</span><span class="o">*</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Resume</span><span class="p">();</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">GetTimeOut</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Transform</span><span class="p">,</span> <span class="p">(</span><span class="n">Gadget</span><span class="o">*</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>

  <span class="c1">// The following must be in the public section, even though the</span>
  <span class="c1">// methods are protected or private in the base class.</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Resume</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">GetTimeOut</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-overloaded-methods">
<h3>Mocking Overloaded Methods<a class="headerlink" href="#mocking-overloaded-methods" title="Permalink to this headline">¶</a></h3>
<p>You can mock overloaded functions as usual. No special attention is required:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// Must be virtual as we&#39;ll inherit from Foo.</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

  <span class="c1">// Overloaded on the types and/or numbers of arguments.</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="n">Element</span> <span class="n">x</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">times</span><span class="p">,</span> <span class="n">Element</span> <span class="n">x</span><span class="p">);</span>

  <span class="c1">// Overloaded on the const-ness of this object.</span>
  <span class="k">virtual</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">GetBar</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">GetBar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="p">(</span><span class="n">Element</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">times</span><span class="p">,</span> <span class="n">Element</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>

  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>{: .callout .note}
<strong>Note:</strong> if you don’t mock all versions of the overloaded method, the compiler
will give you a warning about some methods in the base class being hidden. To
fix that, use <code class="docutils literal notranslate"><span class="pre">using</span></code> to bring them in scope:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">using</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Add</span><span class="p">;</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="p">(</span><span class="n">Element</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="c1">// We don&#39;t want to mock int Add(int times, Element x);</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-class-templates">
<h3>Mocking Class Templates<a class="headerlink" href="#mocking-class-templates" title="Permalink to this headline">¶</a></h3>
<p>You can mock class templates just like any class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StackInterface</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Must be virtual as we&#39;ll inherit from StackInterface.</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">StackInterface</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">GetSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Elem</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MockStack</span> <span class="o">:</span> <span class="k">public</span> <span class="n">StackInterface</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">GetSize</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Push</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-non-virtual-methods-mockingnonvirtualmethods">
<h3>Mocking Non-virtual Methods {#MockingNonVirtualMethods}<a class="headerlink" href="#mocking-non-virtual-methods-mockingnonvirtualmethods" title="Permalink to this headline">¶</a></h3>
<p>gMock can mock non-virtual functions to be used in Hi-perf dependency injection.</p>
<p>In this case, instead of sharing a common base class with the real class, your
mock class will be <em>unrelated</em> to the real class, but contain methods with the
same signatures. The syntax for mocking non-virtual methods is the <em>same</em> as
mocking virtual methods (just don’t add <code class="docutils literal notranslate"><span class="pre">override</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A simple packet stream class.  None of its members is virtual.</span>
<span class="k">class</span> <span class="nc">ConcretePacketStream</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">AppendPacket</span><span class="p">(</span><span class="n">Packet</span><span class="o">*</span> <span class="n">new_packet</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Packet</span><span class="o">*</span> <span class="nf">GetPacket</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">packet_number</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="nf">NumberOfPackets</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// A mock packet stream class.  It inherits from no other, but defines</span>
<span class="c1">// GetPacket() and NumberOfPackets().</span>
<span class="k">class</span> <span class="nc">MockPacketStream</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span> <span class="n">Packet</span><span class="o">*</span><span class="p">,</span> <span class="n">GetPacket</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">packet_number</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">NumberOfPackets</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that the mock class doesn’t define <code class="docutils literal notranslate"><span class="pre">AppendPacket()</span></code>, unlike the real class.
That’s fine as long as the test doesn’t need to call it.</p>
<p>Next, you need a way to say that you want to use <code class="docutils literal notranslate"><span class="pre">ConcretePacketStream</span></code> in
production code, and use <code class="docutils literal notranslate"><span class="pre">MockPacketStream</span></code> in tests. Since the functions are
not virtual and the two classes are unrelated, you must specify your choice at
<em>compile time</em> (as opposed to run time).</p>
<p>One way to do it is to templatize your code that needs to use a packet stream.
More specifically, you will give your code a template type argument for the type
of the packet stream. In production, you will instantiate your template with
<code class="docutils literal notranslate"><span class="pre">ConcretePacketStream</span></code> as the type argument. In tests, you will instantiate the
same template with <code class="docutils literal notranslate"><span class="pre">MockPacketStream</span></code>. For example, you may write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">PacketStream</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CreateConnection</span><span class="p">(</span><span class="n">PacketStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">PacketStream</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">PacketReader</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">ReadPackets</span><span class="p">(</span><span class="n">PacketStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">packet_num</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then you can use <code class="docutils literal notranslate"><span class="pre">CreateConnection&lt;ConcretePacketStream&gt;()</span></code> and
<code class="docutils literal notranslate"><span class="pre">PacketReader&lt;ConcretePacketStream&gt;</span></code> in production code, and use
<code class="docutils literal notranslate"><span class="pre">CreateConnection&lt;MockPacketStream&gt;()</span></code> and <code class="docutils literal notranslate"><span class="pre">PacketReader&lt;MockPacketStream&gt;</span></code> in
tests.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">MockPacketStream</span> <span class="n">mock_stream</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_stream</span><span class="p">,</span> <span class="p">...)...;</span>
  <span class="p">..</span> <span class="n">set</span> <span class="n">more</span> <span class="n">expectations</span> <span class="n">on</span> <span class="n">mock_stream</span> <span class="p">...</span>
  <span class="n">PacketReader</span><span class="o">&lt;</span><span class="n">MockPacketStream</span><span class="o">&gt;</span> <span class="n">reader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_stream</span><span class="p">);</span>
  <span class="p">...</span> <span class="n">exercise</span> <span class="n">reader</span> <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-free-functions">
<h3>Mocking Free Functions<a class="headerlink" href="#mocking-free-functions" title="Permalink to this headline">¶</a></h3>
<p>It is not possible to directly mock a free function (i.e. a C-style function or
a static method). If you need to, you can rewrite your code to use an interface
(abstract class).</p>
<p>Instead of calling a free function (say, <code class="docutils literal notranslate"><span class="pre">OpenFile</span></code>) directly, introduce an
interface for it and have a concrete subclass that calls the free function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FileInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">File</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FileInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">Open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">OpenFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Your code should talk to <code class="docutils literal notranslate"><span class="pre">FileInterface</span></code> to open a file. Now it’s easy to mock
out the function.</p>
<p>This may seem like a lot of hassle, but in practice you often have multiple
related functions that you can put in the same interface, so the per-function
syntactic overhead will be much lower.</p>
<p>If you are concerned about the performance overhead incurred by virtual
functions, and profiling confirms your concern, you can combine this with the
recipe for <a class="reference external" href="#MockingNonVirtualMethods">mocking non-virtual methods</a>.</p>
</div>
<div class="section" id="old-style-mock-methodn-macros">
<h3>Old-Style <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code> Macros<a class="headerlink" href="#old-style-mock-methodn-macros" title="Permalink to this headline">¶</a></h3>
<p>Before the generic <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> macro
<a class="reference external" href="https://github.com/google/googletest/commit/c5f08bf91944ce1b19bcf414fa1760e69d20afc2">was introduced in 2018</a>,
mocks where created using a family of macros collectively called <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code>.
These macros are still supported, though migration to the new <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> is
recommended.</p>
<p>The macros in the <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code> family differ from <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>:</p>
<ul class="simple">
<li><p>The general structure is <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn(MethodName,</span> <span class="pre">ReturnType(Args))</span></code>,
instead of <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD(ReturnType,</span> <span class="pre">MethodName,</span> <span class="pre">(Args))</span></code>.</p></li>
<li><p>The number <code class="docutils literal notranslate"><span class="pre">n</span></code> must equal the number of arguments.</p></li>
<li><p>When mocking a const method, one must use <code class="docutils literal notranslate"><span class="pre">MOCK_CONST_METHODn</span></code>.</p></li>
<li><p>When mocking a class template, the macro name must be suffixed with <code class="docutils literal notranslate"><span class="pre">_T</span></code>.</p></li>
<li><p>In order to specify the call type, the macro name must be suffixed with
<code class="docutils literal notranslate"><span class="pre">_WITH_CALLTYPE</span></code>, and the call type is the first macro argument.</p></li>
</ul>
<p>Old macros and their new equivalents:</p>
<table>
  <tr><th colspan=2>Simple</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int))</code></td>
  </tr>  <tr><th colspan=2>Const Method</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const))</code></td>
  </tr>  <tr><th colspan=2>Method in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_T(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int))</code></td>
  </tr>  <tr><th colspan=2>Const Method in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_T(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const))</code></td>
  </tr>  <tr><th colspan=2>Method with Call Type</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>  <tr><th colspan=2>Const Method with Call Type</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>  <tr><th colspan=2>Method with Call Type in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>  <tr><th colspan=2>Const Method with Call Type in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>
</table></div>
<div class="section" id="the-nice-the-strict-and-the-naggy-nicestrictnaggy">
<h3>The Nice, the Strict, and the Naggy {#NiceStrictNaggy}<a class="headerlink" href="#the-nice-the-strict-and-the-naggy-nicestrictnaggy" title="Permalink to this headline">¶</a></h3>
<p>If a mock method has no <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> spec but is called, we say that it’s an
“uninteresting call”, and the default action (which can be specified using
<code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>) of the method will be taken. Currently, an uninteresting call will
also by default cause gMock to print a warning. (In the future, we might remove
this warning by default.)</p>
<p>However, sometimes you may want to ignore these uninteresting calls, and
sometimes you may want to treat them as errors. gMock lets you make the decision
on a per-mock-object basis.</p>
<p>Suppose your test uses a mock class <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">MockFoo</span> <span class="n">mock_foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">());</span>
  <span class="p">...</span> <span class="n">code</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">mock_foo</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a method of <code class="docutils literal notranslate"><span class="pre">mock_foo</span></code> other than <code class="docutils literal notranslate"><span class="pre">DoThis()</span></code> is called, you will get a
warning. However, if you rewrite your test to use <code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> instead,
you can suppress the warning:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NiceMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span> <span class="n">mock_foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">());</span>
  <span class="p">...</span> <span class="n">code</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">mock_foo</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>, so it can be used wherever
<code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> is accepted.</p>
<p>It also works if <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>’s constructor takes some arguments, as
<code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> “inherits” <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>’s constructors:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NiceMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span> <span class="n">mock_foo</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">);</span>  <span class="c1">// Calls MockFoo(5, &quot;hi&quot;).</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">());</span>
  <span class="p">...</span> <span class="n">code</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">mock_foo</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The usage of <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> is similar, except that it makes all uninteresting
calls failures:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StrictMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">StrictMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span> <span class="n">mock_foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">());</span>
  <span class="p">...</span> <span class="n">code</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">mock_foo</span> <span class="p">...</span>

  <span class="c1">// The test will fail if a method of mock_foo other than DoThis()</span>
  <span class="c1">// is called.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>{: .callout .note}
NOTE: <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> only affects <em>uninteresting</em> calls (calls of
<em>methods</em> with no expectations); they do not affect <em>unexpected</em> calls (calls of
methods with expectations, but they don’t match). See
<a class="reference external" href="#uninteresting-vs-unexpected">Understanding Uninteresting vs Unexpected Calls</a>.</p>
<p>There are some caveats though (sadly they are side effects of C++’s
limitations):</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictMock&lt;MockFoo&gt;</span></code> only work for mock methods
defined using the <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> macro <strong>directly</strong> in the <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> class.
If a mock method is defined in a <strong>base class</strong> of <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>, the “nice” or
“strict” modifier may not affect it, depending on the compiler. In
particular, nesting <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> (e.g.
<code class="docutils literal notranslate"><span class="pre">NiceMock&lt;StrictMock&lt;MockFoo&gt;</span> <span class="pre">&gt;</span></code>) is <strong>not</strong> supported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictMock&lt;MockFoo&gt;</span></code> may not work correctly if the
destructor of <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> is not virtual. We would like to fix this, but it
requires cleaning up existing tests.</p></li>
</ol>
<p>Finally, you should be <strong>very cautious</strong> about when to use naggy or strict
mocks, as they tend to make tests more brittle and harder to maintain. When you
refactor your code without changing its externally visible behavior, ideally you
shouldn’t need to update any tests. If your code interacts with a naggy mock,
however, you may start to get spammed with warnings as the result of your
change. Worse, if your code interacts with a strict mock, your tests may start
to fail and you’ll be forced to fix them. Our general recommendation is to use
nice mocks (not yet the default) most of the time, use naggy mocks (the current
default) when developing or debugging tests, and use strict mocks only as the
last resort.</p>
</div>
<div class="section" id="simplifying-the-interface-without-breaking-existing-code-simplerinterfaces">
<h3>Simplifying the Interface without Breaking Existing Code {#SimplerInterfaces}<a class="headerlink" href="#simplifying-the-interface-without-breaking-existing-code-simplerinterfaces" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a method has a long list of arguments that is mostly uninteresting.
For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LogSink</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="n">LogSeverity</span> <span class="n">severity</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">full_filename</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">base_filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
                    <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tm_time</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">message_len</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This method’s argument list is lengthy and hard to work with (the <code class="docutils literal notranslate"><span class="pre">message</span></code>
argument is not even 0-terminated). If we mock it as is, using the mock will be
awkward. If, however, we try to simplify this interface, we’ll need to fix all
clients depending on it, which is often infeasible.</p>
<p>The trick is to redispatch the method in the mock class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ScopedMockLog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LogSink</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="n">LogSeverity</span> <span class="n">severity</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">full_filename</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">base_filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="k">const</span> <span class="n">tm</span><span class="o">*</span> <span class="n">tm_time</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">message_len</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// We are only interested in the log severity, full file name, and</span>
    <span class="c1">// log message.</span>
    <span class="n">Log</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">full_filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">message_len</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Implements the mock method:</span>
  <span class="c1">//</span>
  <span class="c1">//   void Log(LogSeverity severity,</span>
  <span class="c1">//            const string&amp; file_path,</span>
  <span class="c1">//            const string&amp; message);</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Log</span><span class="p">,</span>
              <span class="p">(</span><span class="n">LogSeverity</span> <span class="n">severity</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">file_path</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>By defining a new mock method with a trimmed argument list, we make the mock
class more user-friendly.</p>
<p>This technique may also be applied to make overloaded methods more amenable to
mocking. For example, when overloads have been used to implement default
arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockTurtleFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TurtleFactory</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Turtle</span><span class="o">*</span> <span class="n">MakeTurtle</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
  <span class="n">Turtle</span><span class="o">*</span> <span class="n">MakeTurtle</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

  <span class="c1">// the above methods delegate to this one:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Turtle</span><span class="o">*</span><span class="p">,</span> <span class="n">DoMakeTurtle</span><span class="p">,</span> <span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This allows tests that don’t care which overload was invoked to avoid specifying
argument matchers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="n">DoMakeTurtle</span><span class="p">)</span>
    <span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">MakeMockTurtle</span><span class="p">()));</span>
</pre></div>
</div>
</div>
<div class="section" id="alternative-to-mocking-concrete-classes">
<h3>Alternative to Mocking Concrete Classes<a class="headerlink" href="#alternative-to-mocking-concrete-classes" title="Permalink to this headline">¶</a></h3>
<p>Often you may find yourself using classes that don’t implement interfaces. In
order to test your code that uses such a class (let’s call it <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>), you
may be tempted to make the methods of <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> virtual and then mock it.</p>
<p>Try not to do that.</p>
<p>Making a non-virtual function virtual is a big decision. It creates an extension
point where subclasses can tweak your class’ behavior. This weakens your control
on the class because now it’s harder to maintain the class invariants. You
should make a function virtual only when there is a valid reason for a subclass
to override it.</p>
<p>Mocking concrete classes directly is problematic as it creates a tight coupling
between the class and the tests - any small change in the class may invalidate
your tests and make test maintenance a pain.</p>
<p>To avoid such problems, many programmers have been practicing “coding to
interfaces”: instead of talking to the <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> class, your code would define
an interface and talk to it. Then you implement that interface as an adaptor on
top of <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>. In tests, you can easily mock that interface to observe how
your code is doing.</p>
<p>This technique incurs some overhead:</p>
<ul class="simple">
<li><p>You pay the cost of virtual function calls (usually not a problem).</p></li>
<li><p>There is more abstraction for the programmers to learn.</p></li>
</ul>
<p>However, it can also bring significant benefits in addition to better
testability:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Concrete</span></code>’s API may not fit your problem domain very well, as you may not
be the only client it tries to serve. By designing your own interface, you
have a chance to tailor it to your need - you may add higher-level
functionalities, rename stuff, etc instead of just trimming the class. This
allows you to write your code (user of the interface) in a more natural way,
which means it will be more readable, more maintainable, and you’ll be more
productive.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>’s implementation ever has to change, you don’t have to rewrite
everywhere it is used. Instead, you can absorb the change in your
implementation of the interface, and your other code and tests will be
insulated from this change.</p></li>
</ul>
<p>Some people worry that if everyone is practicing this technique, they will end
up writing lots of redundant code. This concern is totally understandable.
However, there are two reasons why it may not be the case:</p>
<ul class="simple">
<li><p>Different projects may need to use <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> in different ways, so the best
interfaces for them will be different. Therefore, each of them will have its
own domain-specific interface on top of <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>, and they will not be the
same code.</p></li>
<li><p>If enough projects want to use the same interface, they can always share it,
just like they have been sharing <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>. You can check in the interface
and the adaptor somewhere near <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> (perhaps in a <code class="docutils literal notranslate"><span class="pre">contrib</span></code>
sub-directory) and let many projects use it.</p></li>
</ul>
<p>You need to weigh the pros and cons carefully for your particular problem, but
I’d like to assure you that the Java community has been practicing this for a
long time and it’s a proven effective technique applicable in a wide variety of
situations. :-)</p>
</div>
<div class="section" id="delegating-calls-to-a-fake-delegatingtofake">
<h3>Delegating Calls to a Fake {#DelegatingToFake}<a class="headerlink" href="#delegating-calls-to-a-fake-delegatingtofake" title="Permalink to this headline">¶</a></h3>
<p>Some times you have a non-trivial fake implementation of an interface. For
example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">char</span> <span class="n">DoThis</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DoThat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FakeFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">char</span> <span class="n">DoThis</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;+&#39;</span> <span class="o">:</span>
           <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;-&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">DoThat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now you want to mock this interface such that you can set expectations on it.
However, you also want to use <code class="docutils literal notranslate"><span class="pre">FakeFoo</span></code> for the default behavior, as duplicating
it in the mock object is, well, a lot of work.</p>
<p>When you define the mock class using gMock, you can have it delegate its default
action to a fake class you already have, using this pattern:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Normal mock method definitions using gMock.</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>

  <span class="c1">// Delegates the default actions of the methods to a FakeFoo object.</span>
  <span class="c1">// This must be called *before* the custom ON_CALL() statements.</span>
  <span class="kt">void</span> <span class="nf">DelegateToFake</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">fake_</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fake_</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">FakeFoo</span> <span class="n">fake_</span><span class="p">;</span>  <span class="c1">// Keeps an instance of the fake in the mock.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With that, you can use <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> in your tests as usual. Just remember that if
you don’t explicitly set an action in an <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> or <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, the
fake will be called upon to do it.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">AbcTest</span><span class="p">,</span> <span class="n">Xyz</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>

  <span class="n">foo</span><span class="p">.</span><span class="n">DelegateToFake</span><span class="p">();</span>  <span class="c1">// Enables the fake for delegation.</span>

  <span class="c1">// Put your ON_CALL(foo, ...)s here, if any.</span>

  <span class="c1">// No action specified, meaning to use the default action.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">));</span>

  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>  <span class="c1">// FakeFoo::DoThis() is invoked.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// FakeFoo::DoThat() is invoked.</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Some tips:</strong></p>
<ul class="simple">
<li><p>If you want, you can still override the default action by providing your own
<code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> or using <code class="docutils literal notranslate"><span class="pre">.WillOnce()</span></code> / <code class="docutils literal notranslate"><span class="pre">.WillRepeatedly()</span></code> in <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">DelegateToFake()</span></code>, you only need to delegate the methods whose fake
implementation you intend to use.</p></li>
<li><p>The general technique discussed here works for overloaded methods, but
you’ll need to tell the compiler which version you mean. To disambiguate a
mock function (the one you specify inside the parentheses of <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>),
use <a class="reference external" href="#SelectOverload">this technique</a>; to disambiguate a fake function (the
one you place inside <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code>), use a <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> to specify the
function’s type. For instance, if class <code class="docutils literal notranslate"><span class="pre">Foo</span></code> has methods <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">DoThis(int</span> <span class="pre">n)</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">DoThis(double</span> <span class="pre">x)</span> <span class="pre">const</span></code>, and you want to invoke the latter,
you need to write <code class="docutils literal notranslate"><span class="pre">Invoke(&amp;fake_,</span> <span class="pre">static_cast&lt;bool</span> <span class="pre">(FakeFoo::*)(double)</span> <span class="pre">const&gt;(&amp;FakeFoo::DoThis))</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Invoke(&amp;fake_,</span> <span class="pre">&amp;FakeFoo::DoThis)</span></code>
(The strange-looking thing inside the angled brackets of <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> is
the type of a function pointer to the second <code class="docutils literal notranslate"><span class="pre">DoThis()</span></code> method.).</p></li>
<li><p>Having to mix a mock and a fake is often a sign of something gone wrong.
Perhaps you haven’t got used to the interaction-based way of testing yet. Or
perhaps your interface is taking on too many roles and should be split up.
Therefore, <strong>don’t abuse this</strong>. We would only recommend to do it as an
intermediate step when you are refactoring your code.</p></li>
</ul>
<p>Regarding the tip on mixing a mock and a fake, here’s an example on why it may
be a bad sign: Suppose you have a class <code class="docutils literal notranslate"><span class="pre">System</span></code> for low-level system
operations. In particular, it does file and I/O operations. And suppose you want
to test how your code uses <code class="docutils literal notranslate"><span class="pre">System</span></code> to do I/O, and you just want the file
operations to work normally. If you mock out the entire <code class="docutils literal notranslate"><span class="pre">System</span></code> class, you’ll
have to provide a fake implementation for the file operation part, which
suggests that <code class="docutils literal notranslate"><span class="pre">System</span></code> is taking on too many roles.</p>
<p>Instead, you can define a <code class="docutils literal notranslate"><span class="pre">FileOps</span></code> interface and an <code class="docutils literal notranslate"><span class="pre">IOOps</span></code> interface and split
<code class="docutils literal notranslate"><span class="pre">System</span></code>’s functionalities into the two. Then you can mock <code class="docutils literal notranslate"><span class="pre">IOOps</span></code> without
mocking <code class="docutils literal notranslate"><span class="pre">FileOps</span></code>.</p>
</div>
<div class="section" id="delegating-calls-to-a-real-object">
<h3>Delegating Calls to a Real Object<a class="headerlink" href="#delegating-calls-to-a-real-object" title="Permalink to this headline">¶</a></h3>
<p>When using testing doubles (mocks, fakes, stubs, and etc), sometimes their
behaviors will differ from those of the real objects. This difference could be
either intentional (as in simulating an error such that you can test the error
handling code) or unintentional. If your mocks have different behaviors than the
real objects by mistake, you could end up with code that passes the tests but
fails in production.</p>
<p>You can use the <em>delegating-to-real</em> technique to ensure that your mock has the
same behavior as the real object while retaining the ability to validate calls.
This technique is very similar to the <a class="reference external" href="#DelegatingToFake">delegating-to-fake</a>
technique, the difference being that we use a real object instead of a fake.
Here’s an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AtLeast</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MockFoo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// By default, all calls are delegated to the real object.</span>
    <span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">real_</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">real_</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">...);</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">...);</span>
  <span class="p">...</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">Foo</span> <span class="n">real_</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">mock</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">())</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">))</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="p">...</span> <span class="n">use</span> <span class="n">mock</span> <span class="n">in</span> <span class="n">test</span> <span class="p">...</span>
</pre></div>
</div>
<p>With this, gMock will verify that your code made the right calls (with the right
arguments, in the right order, called the right number of times, etc), and a
real object will answer the calls (so the behavior will be the same as in
production). This gives you the best of both worlds.</p>
</div>
<div class="section" id="delegating-calls-to-a-parent-class">
<h3>Delegating Calls to a Parent Class<a class="headerlink" href="#delegating-calls-to-a-parent-class" title="Permalink to this headline">¶</a></h3>
<p>Ideally, you should code to interfaces, whose methods are all pure virtual. In
reality, sometimes you do need to mock a virtual method that is not pure (i.e,
it already has an implementation). For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Pure</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Concrete</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Mocking a pure method.</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Pure</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="c1">// Mocking a concrete method.  Foo::Concrete() is shadowed.</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Concrete</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sometimes you may want to call <code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">MockFoo::Concrete()</span></code>. Perhaps you want to do it as part of a stub action, or
perhaps your test doesn’t need to mock <code class="docutils literal notranslate"><span class="pre">Concrete()</span></code> at all (but it would be
oh-so painful to have to define a new mock class whenever you don’t need to mock
one of its methods).</p>
<p>You can call <code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> inside an action by:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Concrete</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">([</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Concrete</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
  <span class="p">});</span>
</pre></div>
</div>
<p>or tell the mock object that you don’t want to mock <code class="docutils literal notranslate"><span class="pre">Concrete()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
  <span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Concrete</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">](</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Concrete</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
  <span class="p">});</span>
</pre></div>
</div>
<p>(Why don’t we just write <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">return</span> <span class="pre">foo.Concrete(str);</span> <span class="pre">}</span></code>? If you do that,
<code class="docutils literal notranslate"><span class="pre">MockFoo::Concrete()</span></code> will be called (and cause an infinite recursion) since
<code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> is virtual. That’s just how C++ works.)</p>
</div>
</div>
<div class="section" id="using-matchers">
<h2>Using Matchers<a class="headerlink" href="#using-matchers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="matching-argument-values-exactly">
<h3>Matching Argument Values Exactly<a class="headerlink" href="#matching-argument-values-exactly" title="Permalink to this headline">¶</a></h3>
<p>You can specify exactly which arguments a mock method is expecting:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="using-simple-matchers">
<h3>Using Simple Matchers<a class="headerlink" href="#using-simple-matchers" title="Permalink to this headline">¶</a></h3>
<p>You can use matchers to match arguments that have a certain property:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>  <span class="c1">// The argument must be &gt;= 5.</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">NotNull</span><span class="p">()));</span>
      <span class="c1">// The second argument must not be NULL.</span>
</pre></div>
</div>
<p>A frequently used matcher is <code class="docutils literal notranslate"><span class="pre">_</span></code>, which matches anything:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">NotNull</span><span class="p">()));</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-matchers-combiningmatchers">
<h3>Combining Matchers {#CombiningMatchers}<a class="headerlink" href="#combining-matchers-combiningmatchers" title="Permalink to this headline">¶</a></h3>
<p>You can build complex matchers from existing ones using <code class="docutils literal notranslate"><span class="pre">AllOf()</span></code>,
<code class="docutils literal notranslate"><span class="pre">AllOfArray()</span></code>, <code class="docutils literal notranslate"><span class="pre">AnyOf()</span></code>, <code class="docutils literal notranslate"><span class="pre">AnyOfArray()</span></code> and <code class="docutils literal notranslate"><span class="pre">Not()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">HasSubstr</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Not</span><span class="p">;</span>
<span class="p">...</span>
  <span class="c1">// The argument must be &gt; 5 and != 10.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                                <span class="n">Ne</span><span class="p">(</span><span class="mi">10</span><span class="p">))));</span>

  <span class="c1">// The first argument must not contain sub-string &quot;blah&quot;.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">HasSubstr</span><span class="p">(</span><span class="s">&quot;blah&quot;</span><span class="p">)),</span>
                          <span class="nb">NULL</span><span class="p">));</span>
</pre></div>
</div>
<p>Matchers are function objects, and parametrized matchers can be composed just
like any other function. However because their types can be long and rarely
provide meaningful information, it can be easier to express them with C++14
generic lambdas to avoid specifying types. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Contains</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Property</span><span class="p">;</span>

<span class="kr">inline</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">HasFoo</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Property</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">foo</span><span class="p">,</span> <span class="n">Contains</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">HasFoo</span><span class="p">(</span><span class="s">&quot;blah&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="casting-matchers-safematchercast">
<h3>Casting Matchers {#SafeMatcherCast}<a class="headerlink" href="#casting-matchers-safematchercast" title="Permalink to this headline">¶</a></h3>
<p>gMock matchers are statically typed, meaning that the compiler can catch your
mistake if you use a matcher of the wrong type (for example, if you use <code class="docutils literal notranslate"><span class="pre">Eq(5)</span></code>
to match a <code class="docutils literal notranslate"><span class="pre">string</span></code> argument). Good for you!</p>
<p>Sometimes, however, you know what you’re doing and want the compiler to give you
some slack. One example is that you have a matcher for <code class="docutils literal notranslate"><span class="pre">long</span></code> and the argument
you want to match is <code class="docutils literal notranslate"><span class="pre">int</span></code>. While the two types aren’t exactly the same, there
is nothing really wrong with using a <code class="docutils literal notranslate"><span class="pre">Matcher&lt;long&gt;</span></code> to match an <code class="docutils literal notranslate"><span class="pre">int</span></code> - after
all, we can first convert the <code class="docutils literal notranslate"><span class="pre">int</span></code> argument to a <code class="docutils literal notranslate"><span class="pre">long</span></code> losslessly before
giving it to the matcher.</p>
<p>To support this need, gMock gives you the <code class="docutils literal notranslate"><span class="pre">SafeMatcherCast&lt;T&gt;(m)</span></code> function. It
casts a matcher <code class="docutils literal notranslate"><span class="pre">m</span></code> to type <code class="docutils literal notranslate"><span class="pre">Matcher&lt;T&gt;</span></code>. To ensure safety, gMock checks that
(let <code class="docutils literal notranslate"><span class="pre">U</span></code> be the type <code class="docutils literal notranslate"><span class="pre">m</span></code> accepts :</p>
<ol class="simple">
<li><p>Type <code class="docutils literal notranslate"><span class="pre">T</span></code> can be <em>implicitly</em> cast to type <code class="docutils literal notranslate"><span class="pre">U</span></code>;</p></li>
<li><p>When both <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">U</span></code> are built-in arithmetic types (<code class="docutils literal notranslate"><span class="pre">bool</span></code>, integers, and
floating-point numbers), the conversion from <code class="docutils literal notranslate"><span class="pre">T</span></code> to <code class="docutils literal notranslate"><span class="pre">U</span></code> is not lossy (in
other words, any value representable by <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be represented by <code class="docutils literal notranslate"><span class="pre">U</span></code>);
and</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">U</span></code> is a reference, <code class="docutils literal notranslate"><span class="pre">T</span></code> must also be a reference (as the underlying
matcher may be interested in the address of the <code class="docutils literal notranslate"><span class="pre">U</span></code> value).</p></li>
</ol>
<p>The code won’t compile if any of these conditions isn’t met.</p>
<p>Here’s one example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SafeMatcherCast</span><span class="p">;</span>

<span class="c1">// A base class and a child class.</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">derived</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="c1">// m is a Matcher&lt;Base*&gt; we got from somewhere.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">SafeMatcherCast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">)));</span>
</pre></div>
</div>
<p>If you find <code class="docutils literal notranslate"><span class="pre">SafeMatcherCast&lt;T&gt;(m)</span></code> too limiting, you can use a similar function
<code class="docutils literal notranslate"><span class="pre">MatcherCast&lt;T&gt;(m)</span></code>. The difference is that <code class="docutils literal notranslate"><span class="pre">MatcherCast</span></code> works as long as you
can <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> type <code class="docutils literal notranslate"><span class="pre">T</span></code> to type <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MatcherCast</span></code> essentially lets you bypass C++’s type system (<code class="docutils literal notranslate"><span class="pre">static_cast</span></code> isn’t
always safe as it could throw away information, for example), so be careful not
to misuse/abuse it.</p>
</div>
<div class="section" id="selecting-between-overloaded-functions-selectoverload">
<h3>Selecting Between Overloaded Functions {#SelectOverload}<a class="headerlink" href="#selecting-between-overloaded-functions-selectoverload" title="Permalink to this headline">¶</a></h3>
<p>If you expect an overloaded function to be called, the compiler may need some
help on which overloaded version it is.</p>
<p>To disambiguate functions overloaded on the const-ness of this object, use the
<code class="docutils literal notranslate"><span class="pre">Const()</span></code> argument wrapper.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ReturnRef</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">Bar</span> <span class="n">bar1</span><span class="p">,</span> <span class="n">bar2</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">())</span>         <span class="c1">// The non-const GetBar().</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar1</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">Const</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="n">GetBar</span><span class="p">())</span>  <span class="c1">// The const GetBar().</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar2</span><span class="p">));</span>
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">Const()</span></code> is defined by gMock and returns a <code class="docutils literal notranslate"><span class="pre">const</span></code> reference to its argument.)</p>
<p>To disambiguate overloaded functions with the same number of arguments but
different argument types, you may need to specify the exact type of a matcher,
either by wrapping your matcher in <code class="docutils literal notranslate"><span class="pre">Matcher&lt;type&gt;()</span></code>, or using a matcher whose
type is fixed (<code class="docutils literal notranslate"><span class="pre">TypedEq&lt;type&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">An&lt;type&gt;()</span></code>, etc):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">An</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">TypedEq</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Printer</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Print</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Print</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">PrinterTest</span><span class="p">,</span> <span class="n">Print</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MockPrinter</span> <span class="n">printer</span><span class="p">;</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">Print</span><span class="p">(</span><span class="n">An</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()));</span>            <span class="c1">// void Print(int);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">Print</span><span class="p">(</span><span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="mi">5</span><span class="p">))));</span>  <span class="c1">// void Print(int);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">Print</span><span class="p">(</span><span class="n">TypedEq</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)));</span>   <span class="c1">// void Print(char);</span>

  <span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="performing-different-actions-based-on-the-arguments">
<h3>Performing Different Actions Based on the Arguments<a class="headerlink" href="#performing-different-actions-based-on-the-arguments" title="Permalink to this headline">¶</a></h3>
<p>When a mock method is called, the <em>last</em> matching expectation that’s still
active will be selected (think “newer overrides older”). So, you can make a
method do different things depending on its argument values like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
  <span class="c1">// The default case.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;b&#39;</span><span class="p">));</span>
  <span class="c1">// The more specific case.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>Now, if <code class="docutils literal notranslate"><span class="pre">foo.DoThis()</span></code> is called with a value less than 5, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> will be
returned; otherwise <code class="docutils literal notranslate"><span class="pre">'b'</span></code> will be returned.</p>
</div>
<div class="section" id="matching-multiple-arguments-as-a-whole">
<h3>Matching Multiple Arguments as a Whole<a class="headerlink" href="#matching-multiple-arguments-as-a-whole" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it’s not enough to match the arguments individually. For example, we
may want to say that the first argument must be less than the second argument.
The <code class="docutils literal notranslate"><span class="pre">With()</span></code> clause allows us to match all arguments of a mock function as a
whole. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">Ne</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">With</span><span class="p">(</span><span class="n">Lt</span><span class="p">());</span>
</pre></div>
</div>
<p>says that the first argument of <code class="docutils literal notranslate"><span class="pre">InRange()</span></code> must not be 0, and must be less than
the second argument.</p>
<p>The expression inside <code class="docutils literal notranslate"><span class="pre">With()</span></code> must be a matcher of type <code class="docutils literal notranslate"><span class="pre">Matcher&lt;std::tuple&lt;A1,</span> <span class="pre">...,</span> <span class="pre">An&gt;&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">A1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">An</span></code> are the types of the function arguments.</p>
<p>You can also write <code class="docutils literal notranslate"><span class="pre">AllArgs(m)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">m</span></code> inside <code class="docutils literal notranslate"><span class="pre">.With()</span></code>. The two forms
are equivalent, but <code class="docutils literal notranslate"><span class="pre">.With(AllArgs(Lt()))</span></code> is more readable than <code class="docutils literal notranslate"><span class="pre">.With(Lt())</span></code>.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">Args&lt;k1,</span> <span class="pre">...,</span> <span class="pre">kn&gt;(m)</span></code> to match the <code class="docutils literal notranslate"><span class="pre">n</span></code> selected arguments (as a
tuple) against <code class="docutils literal notranslate"><span class="pre">m</span></code>. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Args</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Blah</span><span class="p">)</span>
      <span class="p">.</span><span class="n">With</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Args</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">()),</span> <span class="n">Args</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">())));</span>
</pre></div>
</div>
<p>says that <code class="docutils literal notranslate"><span class="pre">Blah</span></code> will be called with arguments <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">z</span></code>. Note that in this example, it wasn’t necessary to specify the positional
matchers.</p>
<p>As a convenience and example, gMock provides some matchers for 2-tuples,
including the <code class="docutils literal notranslate"><span class="pre">Lt()</span></code> matcher above. See
Multi-argument Matchers for the
complete list.</p>
<p>Note that if you want to pass the arguments to a predicate of your own (e.g.
<code class="docutils literal notranslate"><span class="pre">.With(Args&lt;0,</span> <span class="pre">1&gt;(Truly(&amp;MyPredicate)))</span></code>), that predicate MUST be written to
take a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> as its argument; gMock will pass the <code class="docutils literal notranslate"><span class="pre">n</span></code> selected arguments
as <em>one</em> single tuple to the predicate.</p>
</div>
<div class="section" id="using-matchers-as-predicates">
<h3>Using Matchers as Predicates<a class="headerlink" href="#using-matchers-as-predicates" title="Permalink to this headline">¶</a></h3>
<p>Have you noticed that a matcher is just a fancy predicate that also knows how to
describe itself? Many existing algorithms take predicates as arguments (e.g.
those defined in STL’s <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> header), and it would be a shame if gMock
matchers were not allowed to participate.</p>
<p>Luckily, you can use a matcher where a unary predicate functor is expected by
wrapping it inside the <code class="docutils literal notranslate"><span class="pre">Matches()</span></code> function. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matches</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// How many elements in v are &gt;= 10?</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">count_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Matches</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">10</span><span class="p">)));</span>
</pre></div>
</div>
<p>Since you can build complex matchers from simpler ones easily using gMock, this
gives you a way to conveniently construct composite predicates (doing the same
using STL’s <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> header is just painful). For example, here’s a
predicate that’s satisfied by any number that is &gt;= 0, &lt;= 100, and != 50:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Le</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Matches</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Matches</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Le</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">Ne</span><span class="p">(</span><span class="mi">50</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="using-matchers-in-googletest-assertions">
<h3>Using Matchers in googletest Assertions<a class="headerlink" href="#using-matchers-in-googletest-assertions" title="Permalink to this headline">¶</a></h3>
<p>See EXPECT_THAT in the Assertions
Reference.</p>
</div>
<div class="section" id="using-predicates-as-matchers">
<h3>Using Predicates as Matchers<a class="headerlink" href="#using-predicates-as-matchers" title="Permalink to this headline">¶</a></h3>
<p>gMock provides a set of built-in matchers for matching arguments with expected
values—see the <a class="reference internal" href="reference/matchers.html"><span class="doc">Matchers Reference</span></a> for more information.
In case you find the built-in set lacking, you can use an arbitrary unary
predicate function or functor as a matcher - as long as the predicate accepts a
value of the type you want. You do this by wrapping the predicate inside the
<code class="docutils literal notranslate"><span class="pre">Truly()</span></code> function, for example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Truly</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">IsEven</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">...</span>
  <span class="c1">// Bar() must be called with an even number.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">Truly</span><span class="p">(</span><span class="n">IsEven</span><span class="p">)));</span>
</pre></div>
</div>
<p>Note that the predicate function / functor doesn’t have to return <code class="docutils literal notranslate"><span class="pre">bool</span></code>. It
works as long as the return value can be used as the condition in in statement
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(condition)</span> <span class="pre">...</span></code>.</p>
</div>
<div class="section" id="matching-arguments-that-are-not-copyable">
<h3>Matching Arguments that Are Not Copyable<a class="headerlink" href="#matching-arguments-that-are-not-copyable" title="Permalink to this headline">¶</a></h3>
<p>When you do an <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(mock_obj,</span> <span class="pre">Foo(bar))</span></code>, gMock saves away a copy of
<code class="docutils literal notranslate"><span class="pre">bar</span></code>. When <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> is called later, gMock compares the argument to <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> with
the saved copy of <code class="docutils literal notranslate"><span class="pre">bar</span></code>. This way, you don’t need to worry about <code class="docutils literal notranslate"><span class="pre">bar</span></code> being
modified or destroyed after the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> is executed. The same is true
when you use matchers like <code class="docutils literal notranslate"><span class="pre">Eq(bar)</span></code>, <code class="docutils literal notranslate"><span class="pre">Le(bar)</span></code>, and so on.</p>
<p>But what if <code class="docutils literal notranslate"><span class="pre">bar</span></code> cannot be copied (i.e. has no copy constructor)? You could
define your own matcher function or callback and use it with <code class="docutils literal notranslate"><span class="pre">Truly()</span></code>, as the
previous couple of recipes have shown. Or, you may be able to get away from it
if you can guarantee that <code class="docutils literal notranslate"><span class="pre">bar</span></code> won’t be changed after the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> is
executed. Just tell gMock that it should save a reference to <code class="docutils literal notranslate"><span class="pre">bar</span></code>, instead of a
copy of it. Here’s how:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Eq</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
  <span class="c1">// Expects that Foo()&#39;s argument == bar.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_obj</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">bar</span><span class="p">))));</span>

  <span class="c1">// Expects that Foo()&#39;s argument &lt; bar.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_obj</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">bar</span><span class="p">))));</span>
</pre></div>
</div>
<p>Remember: if you do this, don’t change <code class="docutils literal notranslate"><span class="pre">bar</span></code> after the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, or the
result is undefined.</p>
</div>
<div class="section" id="validating-a-member-of-an-object">
<h3>Validating a Member of an Object<a class="headerlink" href="#validating-a-member-of-an-object" title="Permalink to this headline">¶</a></h3>
<p>Often a mock function takes a reference to object as an argument. When matching
the argument, you may not want to compare the entire object against a fixed
object, as that may be over-specification. Instead, you may need to validate a
certain member variable or the result of a certain getter method of the object.
You can do this with <code class="docutils literal notranslate"><span class="pre">Field()</span></code> and <code class="docutils literal notranslate"><span class="pre">Property()</span></code>. More specifically,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>is a matcher that matches a <code class="docutils literal notranslate"><span class="pre">Foo</span></code> object whose <code class="docutils literal notranslate"><span class="pre">bar</span></code> member variable satisfies
matcher <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Property</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">baz</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>is a matcher that matches a <code class="docutils literal notranslate"><span class="pre">Foo</span></code> object whose <code class="docutils literal notranslate"><span class="pre">baz()</span></code> method returns a value
that satisfies matcher <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>For example:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>Field(&amp;Foo::number, Ge(3))</code></td>
<td align="left">Matches <code>x</code> where <code>x.number &gt;= 3</code>.</td>
</tr>
<tr>
<td align="left"><code>Property(&amp;Foo::name,  StartsWith("John "))</code></td>
<td align="left">Matches <code>x</code> where <code>x.name()</code> starts with  <code>"John "</code>.</td>
</tr>
</tbody>
</table><p>Note that in <code class="docutils literal notranslate"><span class="pre">Property(&amp;Foo::baz,</span> <span class="pre">...)</span></code>, method <code class="docutils literal notranslate"><span class="pre">baz()</span></code> must take no argument
and be declared as <code class="docutils literal notranslate"><span class="pre">const</span></code>. Don’t use <code class="docutils literal notranslate"><span class="pre">Property()</span></code> against member functions that
you do not own, because taking addresses of functions is fragile and generally
not part of the contract of the function.</p>
<p><code class="docutils literal notranslate"><span class="pre">Field()</span></code> and <code class="docutils literal notranslate"><span class="pre">Property()</span></code> can also match plain pointers to objects. For
instance,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Field</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">number</span><span class="p">,</span> <span class="n">Ge</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>matches a plain pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> where <code class="docutils literal notranslate"><span class="pre">p-&gt;number</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>. If <code class="docutils literal notranslate"><span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the match
will always fail regardless of the inner matcher.</p>
<p>What if you want to validate more than one members at the same time? Remember
that there are <a class="reference external" href="#CombiningMatchers"><code class="docutils literal notranslate"><span class="pre">AllOf()</span></code> and <code class="docutils literal notranslate"><span class="pre">AllOfArray()</span></code></a>.</p>
<p>Finally <code class="docutils literal notranslate"><span class="pre">Field()</span></code> and <code class="docutils literal notranslate"><span class="pre">Property()</span></code> provide overloads that take the field or
property names as the first argument to include it in the error message. This
can be useful when creating combined matchers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Field</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SafeMatcherCast</span><span class="p">;</span>

<span class="n">Matcher</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">IsFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">AllOf</span><span class="p">(</span><span class="n">Field</span><span class="p">(</span><span class="s">&quot;some_field&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">some_field</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">some_field</span><span class="p">),</span>
               <span class="n">Field</span><span class="p">(</span><span class="s">&quot;other_field&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">other_field</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">other_field</span><span class="p">),</span>
               <span class="n">Field</span><span class="p">(</span><span class="s">&quot;last_field&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">last_field</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">last_field</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="validating-the-value-pointed-to-by-a-pointer-argument">
<h3>Validating the Value Pointed to by a Pointer Argument<a class="headerlink" href="#validating-the-value-pointed-to-by-a-pointer-argument" title="Permalink to this headline">¶</a></h3>
<p>C++ functions often take pointers as arguments. You can use matchers like
<code class="docutils literal notranslate"><span class="pre">IsNull()</span></code>, <code class="docutils literal notranslate"><span class="pre">NotNull()</span></code>, and other comparison matchers to match a pointer, but
what if you want to make sure the value <em>pointed to</em> by the pointer, instead of
the pointer itself, has a certain property? Well, you can use the <code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code>
matcher.</p>
<p><code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code> matches a pointer if and only if <code class="docutils literal notranslate"><span class="pre">m</span></code> matches the value the pointer
points to. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Pointee</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">Pointee</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">3</span><span class="p">))));</span>
</pre></div>
</div>
<p>expects <code class="docutils literal notranslate"><span class="pre">foo.Bar()</span></code> to be called with a pointer that points to a value greater
than or equal to 3.</p>
<p>One nice thing about <code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> is that it treats a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer as a match
failure, so you can write <code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code> instead of</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Pointee</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">AllOf</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span> <span class="n">Pointee</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<p>without worrying that a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer will crash your test.</p>
<p>Also, did we tell you that <code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> works with both raw pointers <strong>and</strong>
smart pointers (<code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>, etc)?</p>
<p>What if you have a pointer to pointer? You guessed it - you can use nested
<code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> to probe deeper inside the value. For example,
<code class="docutils literal notranslate"><span class="pre">Pointee(Pointee(Lt(3)))</span></code> matches a pointer that points to a pointer that points
to a number less than 3 (what a mouthful…).</p>
</div>
<div class="section" id="testing-a-certain-property-of-an-object">
<h3>Testing a Certain Property of an Object<a class="headerlink" href="#testing-a-certain-property-of-an-object" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to specify that an object argument has a certain property,
but there is no existing matcher that does this. If you want good error
messages, you should <a class="reference external" href="#NewMatchers">define a matcher</a>. If you want to do it
quick and dirty, you could get away with writing an ordinary function.</p>
<p>Let’s say you have a mock function that takes an object of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, which has
an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar()</span></code> method and an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">baz()</span></code> method, and you want to constrain that
the argument’s <code class="docutils literal notranslate"><span class="pre">bar()</span></code> value plus its <code class="docutils literal notranslate"><span class="pre">baz()</span></code> value is a given number. Here’s
how you can define a matcher to do it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">BarPlusBazEqMatcher</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">BarPlusBazEqMatcher</span><span class="p">(</span><span class="kt">int</span> <span class="n">expected_sum</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">expected_sum_</span><span class="p">(</span><span class="n">expected_sum</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">MatchAndExplain</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">,</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="cm">/* listener */</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span> <span class="o">+</span> <span class="n">foo</span><span class="p">.</span><span class="n">baz</span><span class="p">())</span> <span class="o">==</span> <span class="n">expected_sum_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bar() + baz() equals &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">expected_sum_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bar() + baz() does not equal &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">expected_sum_</span><span class="p">;</span>
  <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">expected_sum_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Matcher</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;&gt;</span> <span class="n">BarPlusBazEq</span><span class="p">(</span><span class="kt">int</span> <span class="n">expected_sum</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">BarPlusBazEqMatcher</span><span class="p">(</span><span class="n">expected_sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(...,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">BarPlusBazEq</span><span class="p">(</span><span class="mi">5</span><span class="p">)))...;</span>
</pre></div>
</div>
</div>
<div class="section" id="matching-containers">
<h3>Matching Containers<a class="headerlink" href="#matching-containers" title="Permalink to this headline">¶</a></h3>
<p>Sometimes an STL container (e.g. list, vector, map, …) is passed to a mock
function and you may want to validate it. Since most STL containers support the
<code class="docutils literal notranslate"><span class="pre">==</span></code> operator, you can write <code class="docutils literal notranslate"><span class="pre">Eq(expected_container)</span></code> or simply
<code class="docutils literal notranslate"><span class="pre">expected_container</span></code> to match a container exactly.</p>
<p>Sometimes, though, you may want to be more flexible (for example, the first
element must be an exact match, but the second element can be any positive
number, and so on). Also, containers used in tests often have a small number of
elements, and having to define the expected container out-of-line is a bit of a
hassle.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">ElementsAre()</span></code> or <code class="docutils literal notranslate"><span class="pre">UnorderedElementsAre()</span></code> matcher in such
cases:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAre</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="mi">5</span><span class="p">)));</span>
</pre></div>
</div>
<p>The above matcher says that the container must have 4 elements, which must be 1,
greater than 0, anything, and 5 respectively.</p>
<p>If you instead write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">UnorderedElementsAre</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">UnorderedElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="mi">5</span><span class="p">)));</span>
</pre></div>
</div>
<p>It means that the container must have 4 elements, which (under some permutation)
must be 1, greater than 0, anything, and 5 respectively.</p>
<p>As an alternative you can place the arguments in a C-style array and use
<code class="docutils literal notranslate"><span class="pre">ElementsAreArray()</span></code> or <code class="docutils literal notranslate"><span class="pre">UnorderedElementsAreArray()</span></code> instead:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAreArray</span><span class="p">;</span>
<span class="p">...</span>
  <span class="c1">// ElementsAreArray accepts an array of element values.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">expected_vector1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">...};</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector1</span><span class="p">)));</span>

  <span class="c1">// Or, an array of element matchers.</span>
  <span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">expected_vector2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="n">Gt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">...};</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector2</span><span class="p">)));</span>
</pre></div>
</div>
<p>In case the array needs to be dynamically created (and therefore the array size
cannot be inferred by the compiler), you can give <code class="docutils literal notranslate"><span class="pre">ElementsAreArray()</span></code> an
additional argument to specify the array size:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAreArray</span><span class="p">;</span>
<span class="p">...</span>
  <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">expected_vector3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
  <span class="p">...</span> <span class="n">fill</span> <span class="n">expected_vector3</span> <span class="n">with</span> <span class="n">values</span> <span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector3</span><span class="p">,</span> <span class="n">count</span><span class="p">)));</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">Pair</span></code> when comparing maps or other associative containers.</p>
<p>{% raw %}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">ElementsAre</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Pair</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ElementsAre</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Pair</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Pair</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)));</span>
</pre></div>
</div>
<p>{% endraw %}</p>
<p><strong>Tips:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code> can be used to match <em>any</em> container that implements the
STL iterator pattern (i.e. it has a <code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> type and supports
<code class="docutils literal notranslate"><span class="pre">begin()/end()</span></code>), not just the ones defined in STL. It will even work with
container types yet to be written - as long as they follows the above
pattern.</p></li>
<li><p>You can use nested <code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code> to match nested (multi-dimensional)
containers.</p></li>
<li><p>If the container is passed by pointer instead of by reference, just write
<code class="docutils literal notranslate"><span class="pre">Pointee(ElementsAre*(...))</span></code>.</p></li>
<li><p>The order of elements <em>matters</em> for <code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code>. If you are using it
with containers whose element order are undefined (e.g. <code class="docutils literal notranslate"><span class="pre">hash_map</span></code>) you
should use <code class="docutils literal notranslate"><span class="pre">WhenSorted</span></code> around <code class="docutils literal notranslate"><span class="pre">ElementsAre</span></code>.</p></li>
</ul>
</div>
<div class="section" id="sharing-matchers">
<h3>Sharing Matchers<a class="headerlink" href="#sharing-matchers" title="Permalink to this headline">¶</a></h3>
<p>Under the hood, a gMock matcher object consists of a pointer to a ref-counted
implementation object. Copying matchers is allowed and very efficient, as only
the pointer is copied. When the last matcher that references the implementation
object dies, the implementation object will be deleted.</p>
<p>Therefore, if you have some complex matcher that you want to use again and
again, there is no need to build it every time. Just assign it to a matcher
variable and use that variable repeatedly! For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Le</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_range</span> <span class="o">=</span> <span class="n">AllOf</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">Le</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="p">...</span> <span class="n">use</span> <span class="n">in_range</span> <span class="n">as</span> <span class="n">a</span> <span class="n">matcher</span> <span class="n">in</span> <span class="n">multiple</span> <span class="n">EXPECT_CALLs</span> <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="matchers-must-have-no-side-effects-purematchers">
<h3>Matchers must have no side-effects {#PureMatchers}<a class="headerlink" href="#matchers-must-have-no-side-effects-purematchers" title="Permalink to this headline">¶</a></h3>
<p>{: .callout .warning}
WARNING: gMock does not guarantee when or how many times a matcher will be
invoked. Therefore, all matchers must be <em>purely functional</em>: they cannot have
any side effects, and the match result must not depend on anything other than
the matcher’s parameters and the value being matched.</p>
<p>This requirement must be satisfied no matter how a matcher is defined (e.g., if
it is one of the standard matchers, or a custom matcher). In particular, a
matcher can never call a mock function, as that will affect the state of the
mock object and gMock.</p>
</div>
</div>
<div class="section" id="setting-expectations">
<h2>Setting Expectations<a class="headerlink" href="#setting-expectations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="knowing-when-to-expect-useoncall">
<h3>Knowing When to Expect {#UseOnCall}<a class="headerlink" href="#knowing-when-to-expect-useoncall" title="Permalink to this headline">¶</a></h3>
<p><strong><code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code></strong> is likely the <em>single most under-utilized construct</em> in gMock.</p>
<p>There are basically two constructs for defining the behavior of a mock object:
<code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> and <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>. The difference? <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> defines what happens when
a mock method is called, but <em>doesn’t imply any expectation on the method
being called</em>. <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> not only defines the behavior, but also sets an
expectation that <em>the method will be called with the given arguments, for the
given number of times</em> (and <em>in the given order</em> when you specify the order
too).</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> does more, isn’t it better than <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code>? Not really. Every
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> adds a constraint on the behavior of the code under test. Having
more constraints than necessary is <em>baaad</em> - even worse than not having enough
constraints.</p>
<p>This may be counter-intuitive. How could tests that verify more be worse than
tests that verify less? Isn’t verification the whole point of tests?</p>
<p>The answer lies in <em>what</em> a test should verify. <strong>A good test verifies the
contract of the code.</strong> If a test over-specifies, it doesn’t leave enough
freedom to the implementation. As a result, changing the implementation without
breaking the contract (e.g. refactoring and optimization), which should be
perfectly fine to do, can break such tests. Then you have to spend time fixing
them, only to see them broken again the next time the implementation is changed.</p>
<p>Keep in mind that one doesn’t have to verify more than one property in one test.
In fact, <strong>it’s a good style to verify only one thing in one test.</strong> If you do
that, a bug will likely break only one or two tests instead of dozens (which
case would you rather debug?). If you are also in the habit of giving tests
descriptive names that tell what they verify, you can often easily guess what’s
wrong just from the test log itself.</p>
<p>So use <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> by default, and only use <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> when you actually intend
to verify that the call is made. For example, you may have a bunch of <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code>s
in your test fixture to set the common mock behavior shared by all tests in the
same group, and write (scarcely) different <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s in different <code class="docutils literal notranslate"><span class="pre">TEST_F</span></code>s
to verify different aspects of the code’s behavior. Compared with the style
where each <code class="docutils literal notranslate"><span class="pre">TEST</span></code> has many <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s, this leads to tests that are more
resilient to implementational changes (and thus less likely to require
maintenance) and makes the intent of the tests more obvious (so they are easier
to maintain when you do need to maintain them).</p>
<p>If you are bothered by the “Uninteresting mock function call” message printed
when a mock method without an <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> is called, you may use a <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code>
instead to suppress all such messages for the mock object, or suppress the
message for specific methods by adding <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(...).Times(AnyNumber())</span></code>. DO
NOT suppress it by blindly adding an <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(...)</span></code>, or you’ll have a test
that’s a pain to maintain.</p>
</div>
<div class="section" id="ignoring-uninteresting-calls">
<h3>Ignoring Uninteresting Calls<a class="headerlink" href="#ignoring-uninteresting-calls" title="Permalink to this headline">¶</a></h3>
<p>If you are not interested in how a mock method is called, just don’t say
anything about it. In this case, if the method is ever called, gMock will
perform its default action to allow the test program to continue. If you are not
happy with the default action taken by gMock, you can override it using
<code class="docutils literal notranslate"><span class="pre">DefaultValue&lt;T&gt;::Set()</span></code> (described <a class="reference external" href="#DefaultValue">here</a>) or <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>.</p>
<p>Please note that once you expressed interest in a particular mock method (via
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>), all invocations to it must match some expectation. If this
function is called but the arguments don’t match any <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statement,
it will be an error.</p>
</div>
<div class="section" id="disallowing-unexpected-calls">
<h3>Disallowing Unexpected Calls<a class="headerlink" href="#disallowing-unexpected-calls" title="Permalink to this headline">¶</a></h3>
<p>If a mock method shouldn’t be called at all, explicitly say so:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>If some calls to the method are allowed, but the rest are not, just list all the
expected calls:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>
</pre></div>
</div>
<p>A call to <code class="docutils literal notranslate"><span class="pre">foo.Bar()</span></code> that doesn’t match any of the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statements
will be an error.</p>
</div>
<div class="section" id="understanding-uninteresting-vs-unexpected-calls-uninteresting-vs-unexpected">
<h3>Understanding Uninteresting vs Unexpected Calls {#uninteresting-vs-unexpected}<a class="headerlink" href="#understanding-uninteresting-vs-unexpected-calls-uninteresting-vs-unexpected" title="Permalink to this headline">¶</a></h3>
<p><em>Uninteresting</em> calls and <em>unexpected</em> calls are different concepts in gMock.
<em>Very</em> different.</p>
<p>A call <code class="docutils literal notranslate"><span class="pre">x.Y(...)</span></code> is <strong>uninteresting</strong> if there’s <em>not even a single</em>
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(x,</span> <span class="pre">Y(...))</span></code> set. In other words, the test isn’t interested in the
<code class="docutils literal notranslate"><span class="pre">x.Y()</span></code> method at all, as evident in that the test doesn’t care to say anything
about it.</p>
<p>A call <code class="docutils literal notranslate"><span class="pre">x.Y(...)</span></code> is <strong>unexpected</strong> if there are <em>some</em> <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(x,</span> <span class="pre">Y(...))</span></code>s set, but none of them matches the call. Put another way, the test is
interested in the <code class="docutils literal notranslate"><span class="pre">x.Y()</span></code> method (therefore it explicitly sets some
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> to verify how it’s called); however, the verification fails as the
test doesn’t expect this particular call to happen.</p>
<p><strong>An unexpected call is always an error,</strong> as the code under test doesn’t behave
the way the test expects it to behave.</p>
<p><strong>By default, an uninteresting call is not an error,</strong> as it violates no
constraint specified by the test. (gMock’s philosophy is that saying nothing
means there is no constraint.) However, it leads to a warning, as it <em>might</em>
indicate a problem (e.g. the test author might have forgotten to specify a
constraint).</p>
<p>In gMock, <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> and <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> can be used to make a mock class “nice” or
“strict”. How does this affect uninteresting calls and unexpected calls?</p>
<p>A <strong>nice mock</strong> suppresses uninteresting call <em>warnings</em>. It is less chatty than
the default mock, but otherwise is the same. If a test fails with a default
mock, it will also fail using a nice mock instead. And vice versa. Don’t expect
making a mock nice to change the test’s result.</p>
<p>A <strong>strict mock</strong> turns uninteresting call warnings into errors. So making a
mock strict may change the test’s result.</p>
<p>Let’s look at an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockDomainRegistry</span><span class="o">&gt;</span> <span class="n">mock_registry</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span> <span class="n">GetDomainOwner</span><span class="p">(</span><span class="s">&quot;google.com&quot;</span><span class="p">))</span>
          <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="s">&quot;Larry Page&quot;</span><span class="p">));</span>

  <span class="c1">// Use mock_registry in code under test.</span>
  <span class="p">...</span> <span class="o">&amp;</span><span class="n">mock_registry</span> <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The sole <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> here says that all calls to <code class="docutils literal notranslate"><span class="pre">GetDomainOwner()</span></code> must have
<code class="docutils literal notranslate"><span class="pre">&quot;google.com&quot;</span></code> as the argument. If <code class="docutils literal notranslate"><span class="pre">GetDomainOwner(&quot;yahoo.com&quot;)</span></code> is called, it
will be an unexpected call, and thus an error. <em>Having a nice mock doesn’t
change the severity of an unexpected call.</em></p>
<p>So how do we tell gMock that <code class="docutils literal notranslate"><span class="pre">GetDomainOwner()</span></code> can be called with some other
arguments as well? The standard technique is to add a “catch all” <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span> <span class="n">GetDomainOwner</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
        <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>  <span class="c1">// catches all other calls to this method.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span> <span class="n">GetDomainOwner</span><span class="p">(</span><span class="s">&quot;google.com&quot;</span><span class="p">))</span>
        <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="s">&quot;Larry Page&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Remember that <code class="docutils literal notranslate"><span class="pre">_</span></code> is the wildcard matcher that matches anything. With this, if
<code class="docutils literal notranslate"><span class="pre">GetDomainOwner(&quot;google.com&quot;)</span></code> is called, it will do what the second
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> says; if it is called with a different argument, it will do what
the first <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> says.</p>
<p>Note that the order of the two <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s is important, as a newer
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> takes precedence over an older one.</p>
<p>For more on uninteresting calls, nice mocks, and strict mocks, read
<a class="reference external" href="#NiceStrictNaggy">“The Nice, the Strict, and the Naggy”</a>.</p>
</div>
<div class="section" id="ignoring-uninteresting-arguments-parameterlessexpectations">
<h3>Ignoring Uninteresting Arguments {#ParameterlessExpectations}<a class="headerlink" href="#ignoring-uninteresting-arguments-parameterlessexpectations" title="Permalink to this headline">¶</a></h3>
<p>If your test doesn’t care about the parameters (it only cares about the number
or order of calls), you can often simply omit the parameter list:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Expect foo.Bar( ... ) twice with any arguments.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">).</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Delegate to the given method whenever the factory is invoked.</span>
  <span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo_factory</span><span class="p">,</span> <span class="n">MakeFoo</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BuildFooForTest</span><span class="p">);</span>
</pre></div>
</div>
<p>This functionality is only available when a method is not overloaded; to prevent
unexpected behavior it is a compilation error to try to set an expectation on a
method where the specific overload is ambiguous. You can work around this by
supplying a <a class="reference external" href="#SimplerInterfaces">simpler mock interface</a> than the mocked class
provides.</p>
<p>This pattern is also useful when the arguments are interesting, but match logic
is substantially complex. You can leave the argument list unspecified and use
SaveArg actions to <a class="reference external" href="#SaveArgVerify">save the values for later verification</a>. If
you do that, you can easily differentiate calling the method the wrong number of
times from calling it with the wrong arguments.</p>
</div>
<div class="section" id="expecting-ordered-calls-orderedcalls">
<h3>Expecting Ordered Calls {#OrderedCalls}<a class="headerlink" href="#expecting-ordered-calls-orderedcalls" title="Permalink to this headline">¶</a></h3>
<p>Although an <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statement defined later takes precedence when gMock
tries to match a function call with an expectation, by default calls don’t have
to happen in the order <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statements are written. For example, if
the arguments match the matchers in the second <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, but not those in
the first and third, then the second expectation will be used.</p>
<p>If you would rather have all calls occur in the order of the expectations, put
the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statements in a block where you define a variable of type
<code class="docutils literal notranslate"><span class="pre">InSequence</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="n">InSequence</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
        <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>In this example, we expect a call to <code class="docutils literal notranslate"><span class="pre">foo.DoThis(5)</span></code>, followed by two calls to
<code class="docutils literal notranslate"><span class="pre">bar.DoThat()</span></code> where the argument can be anything, which are in turn followed by
a call to <code class="docutils literal notranslate"><span class="pre">foo.DoThis(6)</span></code>. If a call occurred out-of-order, gMock will report an
error.</p>
</div>
<div class="section" id="expecting-partially-ordered-calls-partialorder">
<h3>Expecting Partially Ordered Calls {#PartialOrder}<a class="headerlink" href="#expecting-partially-ordered-calls-partialorder" title="Permalink to this headline">¶</a></h3>
<p>Sometimes requiring everything to occur in a predetermined order can lead to
brittle tests. For example, we may care about <code class="docutils literal notranslate"><span class="pre">A</span></code> occurring before both <code class="docutils literal notranslate"><span class="pre">B</span></code> and
<code class="docutils literal notranslate"><span class="pre">C</span></code>, but aren’t interested in the relative order of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code>. In this case,
the test should reflect our real intent, instead of being overly constraining.</p>
<p>gMock allows you to impose an arbitrary DAG (directed acyclic graph) on the
calls. One way to express the DAG is to use the
After clause of <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>.</p>
<p>Another way is via the <code class="docutils literal notranslate"><span class="pre">InSequence()</span></code> clause (not the same as the <code class="docutils literal notranslate"><span class="pre">InSequence</span></code>
class), which we borrowed from jMock 2. It’s less flexible than <code class="docutils literal notranslate"><span class="pre">After()</span></code>, but
more convenient when you have long chains of sequential calls, as it doesn’t
require you to come up with different names for the expectations in the chains.
Here’s how it works:</p>
<p>If we view <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> statements as nodes in a graph, and add an edge from
node A to node B wherever A must occur before B, we can get a DAG. We use the
term “sequence” to mean a directed path in this DAG. Now, if we decompose the
DAG into sequences, we just need to know which sequences each <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>
belongs to in order to be able to reconstruct the original DAG.</p>
<p>So, to specify the partial order on the expectations we need to do two things:
first to define some <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> objects, and then for each <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> say
which <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> objects it is part of.</p>
<p>Expectations in the same sequence must occur in the order they are written. For
example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Sequence</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">Sequence</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">A</span><span class="p">())</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">B</span><span class="p">())</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="n">C</span><span class="p">())</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">D</span><span class="p">())</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>specifies the following DAG (where <code class="docutils literal notranslate"><span class="pre">s1</span></code> is <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code>, and <code class="docutils literal notranslate"><span class="pre">s2</span></code> is <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">D</span></code>):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>       +---&gt; B
       |
  A ---|
       |
       +---&gt; C ---&gt; D
</pre></div>
</div>
<p>This means that A must occur before B and C, and C must occur before D. There’s
no restriction about the order other than these.</p>
</div>
<div class="section" id="controlling-when-an-expectation-retires">
<h3>Controlling When an Expectation Retires<a class="headerlink" href="#controlling-when-an-expectation-retires" title="Permalink to this headline">¶</a></h3>
<p>When a mock method is called, gMock only considers expectations that are still
active. An expectation is active when created, and becomes inactive (aka
<em>retires</em>) when a call that has to occur later has occurred. For example, in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Sequence</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">Sequence</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="s">&quot;File too large.&quot;</span><span class="p">))</span>      <span class="c1">// #1</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">())</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="s">&quot;Data set is empty.&quot;</span><span class="p">))</span>   <span class="c1">// #2</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="s">&quot;User not found.&quot;</span><span class="p">))</span>      <span class="c1">// #3</span>
      <span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>as soon as either #2 or #3 is matched, #1 will retire. If a warning <code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code> is logged after this, it will be an error.</p>
<p>Note that an expectation doesn’t retire automatically when it’s saturated. For
example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">));</span>                     <span class="c1">// #1</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="s">&quot;File too large.&quot;</span><span class="p">));</span>     <span class="c1">// #2</span>
</pre></div>
</div>
<p>says that there will be exactly one warning with the message <code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code>. If the second warning contains this message too, #2 will match again
and result in an upper-bound-violated error.</p>
<p>If this is not what you want, you can ask an expectation to retire as soon as it
becomes saturated:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">));</span>                     <span class="c1">// #1</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="s">&quot;File too large.&quot;</span><span class="p">))</span>      <span class="c1">// #2</span>
      <span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
</pre></div>
</div>
<p>Here #2 can be used only once, so if you have two warnings with the message
<code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code>, the first will match #2 and the second will match #1 -
there will be no error.</p>
</div>
</div>
<div class="section" id="using-actions">
<h2>Using Actions<a class="headerlink" href="#using-actions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="returning-references-from-mock-methods">
<h3>Returning References from Mock Methods<a class="headerlink" href="#returning-references-from-mock-methods" title="Permalink to this headline">¶</a></h3>
<p>If a mock function’s return type is a reference, you need to use <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">Return()</span></code> to return a result:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ReturnRef</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">GetBar</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="returning-live-values-from-mock-methods">
<h3>Returning Live Values from Mock Methods<a class="headerlink" href="#returning-live-values-from-mock-methods" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Return(x)</span></code> action saves a copy of <code class="docutils literal notranslate"><span class="pre">x</span></code> when the action is created, and
always returns the same value whenever it’s executed. Sometimes you may want to
instead return the <em>live</em> value of <code class="docutils literal notranslate"><span class="pre">x</span></code> (i.e. its value at the time when the
action is <em>executed</em>.). Use either <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code> or <code class="docutils literal notranslate"><span class="pre">ReturnPointee()</span></code> for this
purpose.</p>
<p>If the mock function’s return type is a reference, you can do it using
<code class="docutils literal notranslate"><span class="pre">ReturnRef(x)</span></code>, as shown in the previous recipe (“Returning References from Mock
Methods”). However, gMock doesn’t let you use <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code> in a mock function
whose return type is not a reference, as doing that usually indicates a user
error. So, what shall you do?</p>
<p>Though you may be tempted, DO NOT use <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">GetValue</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">GetValue</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>  <span class="c1">// Wrong!</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">GetValue</span><span class="p">());</span>
</pre></div>
</div>
<p>Unfortunately, it doesn’t work here. The above code will fail with error:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Value of: foo.GetValue()
  Actual: 0
Expected: 42
</pre></div>
</div>
<p>The reason is that <code class="docutils literal notranslate"><span class="pre">Return(*value*)</span></code> converts <code class="docutils literal notranslate"><span class="pre">value</span></code> to the actual return type
of the mock function at the time when the action is <em>created</em>, not when it is
<em>executed</em>. (This behavior was chosen for the action to be safe when <code class="docutils literal notranslate"><span class="pre">value</span></code> is
a proxy object that references some temporary objects.) As a result,
<code class="docutils literal notranslate"><span class="pre">std::ref(x)</span></code> is converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code> value (instead of a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int&amp;</span></code>) when
the expectation is set, and <code class="docutils literal notranslate"><span class="pre">Return(std::ref(x))</span></code> will always return 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">ReturnPointee(pointer)</span></code> was provided to solve this problem specifically. It
returns the value pointed to by <code class="docutils literal notranslate"><span class="pre">pointer</span></code> at the time the action is <em>executed</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">ReturnPointee</span><span class="p">;</span>
<span class="p">...</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">GetValue</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>  <span class="c1">// Note the &amp; here.</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">GetValue</span><span class="p">());</span>  <span class="c1">// This will succeed now.</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-actions">
<h3>Combining Actions<a class="headerlink" href="#combining-actions" title="Permalink to this headline">¶</a></h3>
<p>Want to do more than one thing when a function is called? That’s fine. <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code>
allow you to do sequence of actions every time. Only the return value of the
last action in the sequence will be used.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">action_1</span><span class="p">,</span>
                      <span class="n">action_2</span><span class="p">,</span>
                      <span class="p">...</span>
                      <span class="n">action_n</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="verifying-complex-arguments-saveargverify">
<h3>Verifying Complex Arguments {#SaveArgVerify}<a class="headerlink" href="#verifying-complex-arguments-saveargverify" title="Permalink to this headline">¶</a></h3>
<p>If you want to verify that a method is called with a particular argument but the
match criteria is complex, it can be difficult to distinguish between
cardinality failures (calling the method the wrong number of times) and argument
match failures. Similarly, if you are matching multiple parameters, it may not
be easy to distinguishing which argument failed to match. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Not ideal: this could fail because of a problem with arg1 or arg2, or maybe</span>
  <span class="c1">// just the method wasn&#39;t called.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">SendValues</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">EqualsProto</span><span class="p">(</span> <span class="p">...</span> <span class="p">)));</span>
</pre></div>
</div>
<p>You can instead save the arguments and test them individually:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">SendValues</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual_array</span><span class="p">),</span> <span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual_proto</span><span class="p">)));</span>
  <span class="p">...</span> <span class="n">run</span> <span class="n">the</span> <span class="n">test</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">actual_array</span><span class="p">,</span> <span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">actual_proto</span><span class="p">,</span> <span class="n">EqualsProto</span><span class="p">(</span> <span class="p">...</span> <span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-side-effects-mockingsideeffects">
<h3>Mocking Side Effects {#MockingSideEffects}<a class="headerlink" href="#mocking-side-effects-mockingsideeffects" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a method exhibits its effect not via returning a value but via side
effects. For example, it may change some global state or modify an output
argument. To mock side effects, in general you can define your own action by
implementing <code class="docutils literal notranslate"><span class="pre">::testing::ActionInterface</span></code>.</p>
<p>If all you need to do is to change an output argument, the built-in
<code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> action is convenient:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockMutator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mutator</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Mutate</span><span class="p">,</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">mutate</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">value</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">MockMutator</span> <span class="n">mutator</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span> <span class="n">Mutate</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>In this example, when <code class="docutils literal notranslate"><span class="pre">mutator.Mutate()</span></code> is called, we will assign 5 to the
<code class="docutils literal notranslate"><span class="pre">int</span></code> variable pointed to by argument #1 (0-based).</p>
<p><code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> conveniently makes an internal copy of the value you pass to
it, removing the need to keep the value in scope and alive. The implication
however is that the value must have a copy constructor and assignment operator.</p>
<p>If the mock method also needs to return a value as well, you can chain
<code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> with <code class="docutils literal notranslate"><span class="pre">Return()</span></code> using <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code>, remembering to put the
<code class="docutils literal notranslate"><span class="pre">Return()</span></code> statement last:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockMutator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mutator</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">MutateInt</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">value</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">MockMutator</span> <span class="n">mutator</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span> <span class="n">MutateInt</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                      <span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">)));</span>
</pre></div>
</div>
<p>Note, however, that if you use the <code class="docutils literal notranslate"><span class="pre">ReturnOKWith()</span></code> method, it will override the
values provided by <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> in the response parameters of your function
call.</p>
<p>If the output argument is an array, use the <code class="docutils literal notranslate"><span class="pre">SetArrayArgument&lt;N&gt;(first,</span> <span class="pre">last)</span></code>
action instead. It copies the elements in source range <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">last)</span></code> to the
array pointed to by the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th (0-based) argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArrayArgument</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockArrayMutator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ArrayMutator</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Mutate</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_values</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">MockArrayMutator</span> <span class="n">mutator</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span> <span class="n">Mutate</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArrayArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">values</span> <span class="o">+</span> <span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>This also works when the argument is an output iterator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArrayArgument</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockRolodex</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rolodex</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">GetNames</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">MockRolodex</span> <span class="n">rolodex</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;George&quot;</span><span class="p">,</span> <span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="s">&quot;Thomas&quot;</span><span class="p">};</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">rolodex</span><span class="p">,</span> <span class="n">GetNames</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArrayArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</pre></div>
</div>
</div>
<div class="section" id="changing-a-mock-object-s-behavior-based-on-the-state">
<h3>Changing a Mock Object’s Behavior Based on the State<a class="headerlink" href="#changing-a-mock-object-s-behavior-based-on-the-state" title="Permalink to this headline">¶</a></h3>
<p>If you expect a call to change the behavior of a mock object, you can use
<code class="docutils literal notranslate"><span class="pre">::testing::InSequence</span></code> to specify different behaviors before and after the
call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="p">...</span>
  <span class="p">{</span>
     <span class="n">InSequence</span> <span class="n">seq</span><span class="p">;</span>
     <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span> <span class="n">IsDirty</span><span class="p">())</span>
         <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
     <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span> <span class="n">Flush</span><span class="p">());</span>
     <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span> <span class="n">IsDirty</span><span class="p">())</span>
         <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">my_mock</span><span class="p">.</span><span class="n">FlushIfDirty</span><span class="p">();</span>
</pre></div>
</div>
<p>This makes <code class="docutils literal notranslate"><span class="pre">my_mock.IsDirty()</span></code> return <code class="docutils literal notranslate"><span class="pre">true</span></code> before <code class="docutils literal notranslate"><span class="pre">my_mock.Flush()</span></code> is called
and return <code class="docutils literal notranslate"><span class="pre">false</span></code> afterwards.</p>
<p>If the behavior change is more complex, you can store the effects in a variable
and make a mock method get its return value from that variable:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SaveArg</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="n">ACTION_P</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>
<span class="p">...</span>
  <span class="kt">int</span> <span class="n">previous_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span> <span class="n">GetPrevValue</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous_value</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span> <span class="n">UpdateValue</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous_value</span><span class="p">));</span>
  <span class="n">my_mock</span><span class="p">.</span><span class="n">DoSomethingToUpdateValue</span><span class="p">();</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">my_mock.GetPrevValue()</span></code> will always return the argument of the last
<code class="docutils literal notranslate"><span class="pre">UpdateValue()</span></code> call.</p>
</div>
<div class="section" id="setting-the-default-value-for-a-return-type-defaultvalue">
<h3>Setting the Default Value for a Return Type {#DefaultValue}<a class="headerlink" href="#setting-the-default-value-for-a-return-type-defaultvalue" title="Permalink to this headline">¶</a></h3>
<p>If a mock method’s return type is a built-in C++ type or pointer, by default it
will return 0 when invoked. Also, in C++ 11 and above, a mock method whose
return type has a default constructor will return a default-constructed value by
default. You only need to specify an action if this default value doesn’t work
for you.</p>
<p>Sometimes, you may want to change this default value, or you may want to specify
a default value for types gMock doesn’t know about. You can do this using the
<code class="docutils literal notranslate"><span class="pre">::testing::DefaultValue</span></code> class template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DefaultValue</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="p">,</span> <span class="n">CalculateBar</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>


<span class="p">...</span>
  <span class="n">Bar</span> <span class="n">default_bar</span><span class="p">;</span>
  <span class="c1">// Sets the default return value for type Bar.</span>
  <span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;::</span><span class="n">Set</span><span class="p">(</span><span class="n">default_bar</span><span class="p">);</span>

  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>

  <span class="c1">// We don&#39;t need to specify an action here, as the default</span>
  <span class="c1">// return value works for us.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">CalculateBar</span><span class="p">());</span>

  <span class="n">foo</span><span class="p">.</span><span class="n">CalculateBar</span><span class="p">();</span>  <span class="c1">// This should return default_bar.</span>

  <span class="c1">// Unsets the default return value.</span>
  <span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;::</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</div>
<p>Please note that changing the default value for a type can make your tests hard
to understand. We recommend you to use this feature judiciously. For example,
you may want to make sure the <code class="docutils literal notranslate"><span class="pre">Set()</span></code> and <code class="docutils literal notranslate"><span class="pre">Clear()</span></code> calls are right next to the
code that uses your mock.</p>
</div>
<div class="section" id="setting-the-default-actions-for-a-mock-method">
<h3>Setting the Default Actions for a Mock Method<a class="headerlink" href="#setting-the-default-actions-for-a-mock-method" title="Permalink to this headline">¶</a></h3>
<p>You’ve learned how to change the default value of a given type. However, this
may be too coarse for your purpose: perhaps you have two mock methods with the
same return type and you want them to have different behaviors. The <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>
macro allows you to customize your mock’s behavior at the method level:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Sign</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Sign</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Sign</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
      <span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Sign</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>

  <span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="c1">// This should return 1.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">);</span>  <span class="c1">// This should return -1.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// This should return 0.</span>
</pre></div>
</div>
<p>As you may have guessed, when there are more than one <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> statements,
the newer ones in the order take precedence over the older ones. In other words,
the <strong>last</strong> one that matches the function arguments will be used. This matching
order allows you to set up the common behavior in a mock object’s constructor or
the test fixture’s set-up phase and specialize the mock’s behavior later.</p>
<p>Note that both <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> and <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> have the same “later statements take
precedence” rule, but they don’t interact. That is, <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s have their
own precedence order distinct from the <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> precedence order.</p>
</div>
<div class="section" id="using-functions-methods-functors-lambdas-as-actions-functionsasactions">
<h3>Using Functions/Methods/Functors/Lambdas as Actions {#FunctionsAsActions}<a class="headerlink" href="#using-functions-methods-functors-lambdas-as-actions-functionsasactions" title="Permalink to this headline">¶</a></h3>
<p>If the built-in actions don’t suit you, you can use an existing callable
(function, <code class="docutils literal notranslate"><span class="pre">std::function</span></code>, method, functor, lambda) as an action.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span> <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ComplexJob</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">CalculateSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">Sum3</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">Helper</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">ComplexJob</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">Helper</span> <span class="n">helper</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Sum</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CalculateSum</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">Sum3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">ComplexJob</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">helper</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Helper</span><span class="o">::</span><span class="n">ComplexJob</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">([]</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">})</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>

  <span class="n">foo</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>         <span class="c1">// Invokes CalculateSum(5, 6).</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>         <span class="c1">// Invokes Sum3(1, 2, 3).</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">// Invokes helper.ComplexJob(10).</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// Invokes the inline lambda.</span>
</pre></div>
</div>
<p>The only requirement is that the type of the function, etc must be <em>compatible</em>
with the signature of the mock function, meaning that the latter’s arguments (if
it takes any) can be implicitly converted to the corresponding arguments of the
former, and the former’s return type can be implicitly converted to that of the
latter. So, you can invoke something whose type is <em>not</em> exactly the same as the
mock function, as long as it’s safe to do so - nice, huh?</p>
<p>Note that:</p>
<ul>
<li><p>The action takes ownership of the callback and will delete it when the
action itself is destructed.</p></li>
<li><p>If the type of a callback is derived from a base callback type <code class="docutils literal notranslate"><span class="pre">C</span></code>, you need
to implicitly cast it to <code class="docutils literal notranslate"><span class="pre">C</span></code> to resolve the overloading, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">ResultCallback</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;*</span> <span class="n">is_ok</span> <span class="o">=</span> <span class="p">...;</span>
  <span class="p">...</span> <span class="n">Invoke</span><span class="p">(</span><span class="n">is_ok</span><span class="p">)</span> <span class="p">...;</span>  <span class="c1">// This works.</span>

  <span class="n">BlockingClosure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BlockingClosure</span><span class="p">;</span>
  <span class="p">...</span> <span class="n">Invoke</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">done</span><span class="p">))</span> <span class="p">...;</span>  <span class="c1">// The cast is necessary.</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="using-functions-with-extra-info-as-actions">
<h3>Using Functions with Extra Info as Actions<a class="headerlink" href="#using-functions-with-extra-info-as-actions" title="Permalink to this headline">¶</a></h3>
<p>The function or functor you call using <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> must have the same number of
arguments as the mock function you use it for. Sometimes you may have a function
that takes more arguments, and you are willing to pass in the extra arguments
yourself to fill the gap. You can do this in gMock using callbacks with
pre-bound arguments. Here’s an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">char</span> <span class="nf">SignOfSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;+&#39;</span> <span class="o">:</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;-&#39;</span> <span class="o">:</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span> <span class="n">Test</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">SignOfSum</span><span class="p">,</span> <span class="mi">5</span><span class="p">)));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// Invokes SignOfSum(5, 2).</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="invoking-a-function-method-functor-lambda-callback-without-arguments">
<h3>Invoking a Function/Method/Functor/Lambda/Callback Without Arguments<a class="headerlink" href="#invoking-a-function-method-functor-lambda-callback-without-arguments" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> passes the mock function’s arguments to the function, etc being
invoked such that the callee has the full context of the call to work with. If
the invoked function is not interested in some or all of the arguments, it can
simply ignore them.</p>
<p>Yet, a common pattern is that a test author wants to invoke a function without
the arguments of the mock function. She could do that using a wrapper function
that throws away the arguments before invoking an underlining nullary function.
Needless to say, this can be tedious and obscures the intent of the test.</p>
<p>There are two solutions to this problem. First, you can pass any callable of
zero args as an action. Alternatively, use <code class="docutils literal notranslate"><span class="pre">InvokeWithoutArgs()</span></code>, which is like
<code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> except that it doesn’t pass the mock function’s arguments to the
callee. Here’s an example of each:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeWithoutArgs</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ComplexJob</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">Job1</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">Job2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">ComplexJob</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">([]</span> <span class="p">{</span> <span class="n">Job1</span><span class="p">();</span> <span class="p">});</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">Job2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)));</span>

  <span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// Invokes Job1().</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">// Invokes Job2(5, &#39;a&#39;).</span>
</pre></div>
</div>
<p>Note that:</p>
<ul>
<li><p>The action takes ownership of the callback and will delete it when the
action itself is destructed.</p></li>
<li><p>If the type of a callback is derived from a base callback type <code class="docutils literal notranslate"><span class="pre">C</span></code>, you need
to implicitly cast it to <code class="docutils literal notranslate"><span class="pre">C</span></code> to resolve the overloading, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeWithoutArgs</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">ResultCallback</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;*</span> <span class="n">is_ok</span> <span class="o">=</span> <span class="p">...;</span>
  <span class="p">...</span> <span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">is_ok</span><span class="p">)</span> <span class="p">...;</span>  <span class="c1">// This works.</span>

  <span class="n">BlockingClosure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="p">...;</span>
  <span class="p">...</span> <span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">done</span><span class="p">))</span> <span class="p">...;</span>
  <span class="c1">// The cast is necessary.</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="invoking-an-argument-of-the-mock-function">
<h3>Invoking an Argument of the Mock Function<a class="headerlink" href="#invoking-an-argument-of-the-mock-function" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a mock function will receive a function pointer, a functor (in other
words, a “callable”) as an argument, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">ResultCallback1</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;*</span> <span class="n">callback</span><span class="p">)),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and you may want to invoke this callable argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(...);</span>
      <span class="c1">// Will execute callback-&gt;Run(5), where callback is the</span>
      <span class="c1">// second argument DoThis() receives.</span>
</pre></div>
</div>
<p>{: .callout .note}
NOTE: The section below is legacy documentation from before C++ had lambdas:</p>
<p>Arghh, you need to refer to a mock function argument but C++ has no lambda
(yet), so you have to define your own action. :-( Or do you really?</p>
<p>Well, gMock has an action to solve <em>exactly</em> this problem:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">arg_m</span><span class="p">)</span>
</pre></div>
</div>
<p>will invoke the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th (0-based) argument the mock function receives, with
<code class="docutils literal notranslate"><span class="pre">arg_1</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_2</span></code>, …, and <code class="docutils literal notranslate"><span class="pre">arg_m</span></code>. No matter if the argument is a function
pointer, a functor, or a callback. gMock handles them all.</p>
<p>With that, you could write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
      <span class="c1">// Will execute callback-&gt;Run(5), where callback is the</span>
      <span class="c1">// second argument DoThis() receives.</span>
</pre></div>
</div>
<p>What if the callable takes an argument by reference? No problem - just wrap it
inside <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span>
              <span class="p">((</span><span class="n">ResultCallback2</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">Helper</span><span class="o">&amp;&gt;*</span> <span class="n">callback</span><span class="p">)),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span>
  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">Helper</span> <span class="n">helper</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">helper</span><span class="p">)));</span>
      <span class="c1">// std::ref(helper) guarantees that a reference to helper, not a copy of</span>
      <span class="c1">// it, will be passed to the callback.</span>
</pre></div>
</div>
<p>What if the callable takes an argument by reference and we do <strong>not</strong> wrap the
argument in <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>? Then <code class="docutils literal notranslate"><span class="pre">InvokeArgument()</span></code> will <em>make a copy</em> of the
argument, and pass a <em>reference to the copy</em>, instead of a reference to the
original value, to the callable. This is especially handy when the argument is a
temporary value:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">(</span><span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span>
  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">)));</span>
      <span class="c1">// Will execute (*f)(5.0, string(&quot;Hi&quot;)), where f is the function pointer</span>
      <span class="c1">// DoThat() receives.  Note that the values 5.0 and string(&quot;Hi&quot;) are</span>
      <span class="c1">// temporary and dead once the EXPECT_CALL() statement finishes.  Yet</span>
      <span class="c1">// it&#39;s fine to perform this action later, since a copy of the values</span>
      <span class="c1">// are kept inside the InvokeArgument action.</span>
</pre></div>
</div>
</div>
<div class="section" id="ignoring-an-action-s-result">
<h3>Ignoring an Action’s Result<a class="headerlink" href="#ignoring-an-action-s-result" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you have an action that returns <em>something</em>, but you need an action
that returns <code class="docutils literal notranslate"><span class="pre">void</span></code> (perhaps you want to use it in a mock function that returns
<code class="docutils literal notranslate"><span class="pre">void</span></code>, or perhaps it needs to be used in <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code> and it’s not the last in the
list). <code class="docutils literal notranslate"><span class="pre">IgnoreResult()</span></code> lets you do that. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">IgnoreResult</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">Process</span><span class="p">(</span><span class="k">const</span> <span class="n">MyData</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">DoSomething</span><span class="p">();</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Abc</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">MyData</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Xyz</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

  <span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Abc</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="c1">// .WillOnce(Invoke(Process));</span>
      <span class="c1">// The above line won&#39;t compile as Process() returns int but Abc() needs</span>
      <span class="c1">// to return void.</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">IgnoreResult</span><span class="p">(</span><span class="n">Process</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Xyz</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">IgnoreResult</span><span class="p">(</span><span class="n">DoSomething</span><span class="p">),</span>
                      <span class="c1">// Ignores the string DoSomething() returns.</span>
                      <span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">)));</span>
</pre></div>
</div>
<p>Note that you <strong>cannot</strong> use <code class="docutils literal notranslate"><span class="pre">IgnoreResult()</span></code> on an action that already returns
<code class="docutils literal notranslate"><span class="pre">void</span></code>. Doing so will lead to ugly compiler errors.</p>
</div>
<div class="section" id="selecting-an-action-s-arguments-selectingargs">
<h3>Selecting an Action’s Arguments {#SelectingArgs}<a class="headerlink" href="#selecting-an-action-s-arguments-selectingargs" title="Permalink to this headline">¶</a></h3>
<p>Say you have a mock function <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> that takes seven arguments, and you have a
custom action that you want to invoke when <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> is called. Trouble is, the
custom action only wants three arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span>
              <span class="p">(</span><span class="kt">bool</span> <span class="n">visible</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
               <span class="p">(</span><span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">),</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">double</span> <span class="n">min_weight</span><span class="p">,</span>
               <span class="kt">double</span> <span class="n">max_wight</span><span class="p">));</span>
<span class="p">...</span>
<span class="kt">bool</span> <span class="n">IsVisibleInQuadrant1</span><span class="p">(</span><span class="kt">bool</span> <span class="n">visible</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">visible</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">IsVisibleInQuadrant1</span><span class="p">));</span>  <span class="c1">// Uh, won&#39;t compile. :-(</span>
</pre></div>
</div>
<p>To please the compiler God, you need to define an “adaptor” that has the same
signature as <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> and calls the custom action with the right arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">bool</span> <span class="n">MyIsVisibleInQuadrant1</span><span class="p">(</span><span class="kt">bool</span> <span class="n">visible</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">weight</span><span class="p">,</span>
                            <span class="kt">double</span> <span class="n">min_weight</span><span class="p">,</span> <span class="kt">double</span> <span class="n">max_wight</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IsVisibleInQuadrant1</span><span class="p">(</span><span class="n">visible</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">MyIsVisibleInQuadrant1</span><span class="p">));</span>  <span class="c1">// Now it works.</span>
</pre></div>
</div>
<p>But isn’t this awkward?</p>
<p>gMock provides a generic <em>action adaptor</em>, so you can spend your time minding
more important business than writing your own adaptors. Here’s the syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WithArgs</span><span class="o">&lt;</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">Nk</span><span class="o">&gt;</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
</pre></div>
</div>
<p>creates an action that passes the arguments of the mock function at the given
indices (0-based) to the inner <code class="docutils literal notranslate"><span class="pre">action</span></code> and performs it. Using <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code>, our
original example can be written as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">WithArgs</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">WithArgs</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">IsVisibleInQuadrant1</span><span class="p">)));</span>  <span class="c1">// No need to define your own adaptor.</span>
</pre></div>
</div>
<p>For better readability, gMock also gives you:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WithoutArgs(action)</span></code> when the inner <code class="docutils literal notranslate"><span class="pre">action</span></code> takes <em>no</em> argument, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WithArg&lt;N&gt;(action)</span></code> (no <code class="docutils literal notranslate"><span class="pre">s</span></code> after <code class="docutils literal notranslate"><span class="pre">Arg</span></code>) when the inner <code class="docutils literal notranslate"><span class="pre">action</span></code> takes
<em>one</em> argument.</p></li>
</ul>
<p>As you may have realized, <code class="docutils literal notranslate"><span class="pre">InvokeWithoutArgs(...)</span></code> is just syntactic sugar for
<code class="docutils literal notranslate"><span class="pre">WithoutArgs(Invoke(...))</span></code>.</p>
<p>Here are more tips:</p>
<ul class="simple">
<li><p>The inner action used in <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code> and friends does not have to be
<code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> – it can be anything.</p></li>
<li><p>You can repeat an argument in the argument list if necessary, e.g.
<code class="docutils literal notranslate"><span class="pre">WithArgs&lt;2,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">5&gt;(...)</span></code>.</p></li>
<li><p>You can change the order of the arguments, e.g. <code class="docutils literal notranslate"><span class="pre">WithArgs&lt;3,</span> <span class="pre">2,</span> <span class="pre">1&gt;(...)</span></code>.</p></li>
<li><p>The types of the selected arguments do <em>not</em> have to match the signature of
the inner action exactly. It works as long as they can be implicitly
converted to the corresponding arguments of the inner action. For example,
if the 4-th argument of the mock function is an <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">my_action</span></code> takes
a <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">WithArg&lt;4&gt;(my_action)</span></code> will work.</p></li>
</ul>
</div>
<div class="section" id="ignoring-arguments-in-action-functions">
<h3>Ignoring Arguments in Action Functions<a class="headerlink" href="#ignoring-arguments-in-action-functions" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="#SelectingArgs">selecting-an-action’s-arguments</a> recipe showed us one way
to make a mock function and an action with incompatible argument lists fit
together. The downside is that wrapping the action in <code class="docutils literal notranslate"><span class="pre">WithArgs&lt;...&gt;()</span></code> can get
tedious for people writing the tests.</p>
<p>If you are defining a function (or method, functor, lambda, callback) to be used
with <code class="docutils literal notranslate"><span class="pre">Invoke*()</span></code>, and you are not interested in some of its arguments, an
alternative to <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code> is to declare the uninteresting arguments as <code class="docutils literal notranslate"><span class="pre">Unused</span></code>.
This makes the definition less cluttered and less fragile in case the types of
the uninteresting arguments change. It could also increase the chance the action
function can be reused. For example, given</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span> <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="kt">double</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
</pre></div>
</div>
<p>instead of</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="kt">double</span> <span class="nf">DistanceToOriginWithLabel</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">DistanceToOriginWithIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOriginWithLabel</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOriginWithIndex</span><span class="p">));</span>
</pre></div>
</div>
<p>you could write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Unused</span><span class="p">;</span>

<span class="kt">double</span> <span class="nf">DistanceToOrigin</span><span class="p">(</span><span class="n">Unused</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOrigin</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOrigin</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="sharing-actions">
<h3>Sharing Actions<a class="headerlink" href="#sharing-actions" title="Permalink to this headline">¶</a></h3>
<p>Just like matchers, a gMock action object consists of a pointer to a ref-counted
implementation object. Therefore copying actions is also allowed and very
efficient. When the last action that references the implementation object dies,
the implementation object will be deleted.</p>
<p>If you have some complex action that you want to use again and again, you may
not have to build it from scratch every time. If the action doesn’t have an
internal state (i.e. if it always does the same thing no matter how many times
it has been called), you can assign it to an action variable and use that
variable repeatedly. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">Action</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">set_flag</span> <span class="o">=</span> <span class="n">DoAll</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                                      <span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
  <span class="p">...</span> <span class="n">use</span> <span class="n">set_flag</span> <span class="n">in</span> <span class="p">.</span><span class="n">WillOnce</span><span class="p">()</span> <span class="n">and</span> <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">()</span> <span class="p">...</span>
</pre></div>
</div>
<p>However, if the action has its own state, you may be surprised if you share the
action object. Suppose you have an action factory <code class="docutils literal notranslate"><span class="pre">IncrementCounter(init)</span></code> which
creates an action that increments and returns a counter whose initial value is
<code class="docutils literal notranslate"><span class="pre">init</span></code>, using two actions created from the same expression and using a shared
action will exhibit different behaviors. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span>  <span class="c1">// Returns 1.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span>  <span class="c1">// Returns 2.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">();</span>  <span class="c1">// Returns 1 - Blah() uses a different</span>
                 <span class="c1">// counter than Bar()&#39;s.</span>
</pre></div>
</div>
<p>versus</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">Action</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">increment</span> <span class="o">=</span> <span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">())</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span>  <span class="c1">// Returns 1.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span>  <span class="c1">// Returns 2.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">();</span>  <span class="c1">// Returns 3 - the counter is shared.</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-asynchronous-behavior">
<h3>Testing Asynchronous Behavior<a class="headerlink" href="#testing-asynchronous-behavior" title="Permalink to this headline">¶</a></h3>
<p>One oft-encountered problem with gMock is that it can be hard to test
asynchronous behavior. Suppose you had a <code class="docutils literal notranslate"><span class="pre">EventQueue</span></code> class that you wanted to
test, and you created a separate <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> interface so that you could
easily mock it out. However, the implementation of the class fired all the
events on a background thread, which made test timings difficult. You could just
insert <code class="docutils literal notranslate"><span class="pre">sleep()</span></code> statements and hope for the best, but that makes your test
behavior nondeterministic. A better way is to use gMock actions and
<code class="docutils literal notranslate"><span class="pre">Notification</span></code> objects to force your asynchronous test to behave synchronously.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockEventDispatcher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">EventDispatcher</span> <span class="p">{</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DispatchEvent</span><span class="p">,</span> <span class="p">(</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">EventQueueTest</span><span class="p">,</span> <span class="n">EnqueueEventTest</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MockEventDispatcher</span> <span class="n">mock_event_dispatcher</span><span class="p">;</span>
  <span class="n">EventQueue</span> <span class="nf">event_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_event_dispatcher</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">int32</span> <span class="n">kEventId</span> <span class="o">=</span> <span class="mi">321</span><span class="p">;</span>
  <span class="n">absl</span><span class="o">::</span><span class="n">Notification</span> <span class="n">done</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_event_dispatcher</span><span class="p">,</span> <span class="n">DispatchEvent</span><span class="p">(</span><span class="n">kEventId</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">([</span><span class="o">&amp;</span><span class="n">done</span><span class="p">]</span> <span class="p">{</span> <span class="n">done</span><span class="p">.</span><span class="n">Notify</span><span class="p">();</span> <span class="p">});</span>

  <span class="n">event_queue</span><span class="p">.</span><span class="n">EnqueueEvent</span><span class="p">(</span><span class="n">kEventId</span><span class="p">);</span>
  <span class="n">done</span><span class="p">.</span><span class="n">WaitForNotification</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above, we set our normal gMock expectations, but then add an
additional action to notify the <code class="docutils literal notranslate"><span class="pre">Notification</span></code> object. Now we can just call
<code class="docutils literal notranslate"><span class="pre">Notification::WaitForNotification()</span></code> in the main thread to wait for the
asynchronous call to finish. After that, our test suite is complete and we can
safely exit.</p>
<p>{: .callout .note}
Note: this example has a downside: namely, if the expectation is not satisfied,
our test will run forever. It will eventually time-out and fail, but it will
take longer and be slightly harder to debug. To alleviate this problem, you can
use <code class="docutils literal notranslate"><span class="pre">WaitForNotificationWithTimeout(ms)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">WaitForNotification()</span></code>.</p>
</div>
</div>
<div class="section" id="misc-recipes-on-using-gmock">
<h2>Misc Recipes on Using gMock<a class="headerlink" href="#misc-recipes-on-using-gmock" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mocking-methods-that-use-move-only-types">
<h3>Mocking Methods That Use Move-Only Types<a class="headerlink" href="#mocking-methods-that-use-move-only-types" title="Permalink to this headline">¶</a></h3>
<p>C++11 introduced <em>move-only types</em>. A move-only-typed value can be moved from
one object to another, but cannot be copied. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T&gt;</span></code> is probably
the most commonly used move-only type.</p>
<p>Mocking a method that takes and/or returns move-only types presents some
challenges, but nothing insurmountable. This recipe shows you how you can do it.
Note that the support for move-only method arguments was only introduced to
gMock in April 2017; in older code, you may find more complex
<a class="reference external" href="#LegacyMoveOnly">workarounds</a> for lack of this feature.</p>
<p>Let’s say we are working on a fictional project that lets one post and share
snippets called “buzzes”. Your code uses these types:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">AccessLevel</span> <span class="p">{</span> <span class="n">kInternal</span><span class="p">,</span> <span class="n">kPublic</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">Buzz</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Buzz</span><span class="p">(</span><span class="n">AccessLevel</span> <span class="n">access</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Buzzer</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Buzzer</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span> <span class="n">MakeBuzz</span><span class="p">(</span><span class="n">StringPiece</span> <span class="n">text</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span> <span class="n">buzz</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">Buzz</span></code> object represents a snippet being posted. A class that implements the
<code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> interface is capable of creating and sharing <code class="docutils literal notranslate"><span class="pre">Buzz</span></code>es. Methods in
<code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> may return a <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code> or take a <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code>. Now we
need to mock <code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> in our tests.</p>
<p>To mock a method that accepts or returns move-only types, you just use the
familiar <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> syntax as usual:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockBuzzer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Buzzer</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">MakeBuzz</span><span class="p">,</span> <span class="p">(</span><span class="n">StringPiece</span> <span class="n">text</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ShareBuzz</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span> <span class="n">buzz</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">timestamp</span><span class="p">),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now that we have the mock class defined, we can use it in tests. In the
following code examples, we assume that we have defined a <code class="docutils literal notranslate"><span class="pre">MockBuzzer</span></code> object
named <code class="docutils literal notranslate"><span class="pre">mock_buzzer_</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">MockBuzzer</span> <span class="n">mock_buzzer_</span><span class="p">;</span>
</pre></div>
</div>
<p>First let’s see how we can set expectations on the <code class="docutils literal notranslate"><span class="pre">MakeBuzz()</span></code> method, which
returns a <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code>.</p>
<p>As usual, if you set an expectation without an action (i.e. the <code class="docutils literal notranslate"><span class="pre">.WillOnce()</span></code> or
<code class="docutils literal notranslate"><span class="pre">.WillRepeatedly()</span></code> clause), when that expectation fires, the default action for
that method will be taken. Since <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;&gt;</span></code> has a default constructor that
returns a null <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>, that’s what you’ll get if you don’t specify an
action:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Use the default action.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">));</span>

  <span class="c1">// Triggers the previous EXPECT_CALL.</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>If you are not happy with the default action, you can tweak it as usual; see
<a class="reference external" href="#OnCall">Setting Default Actions</a>.</p>
<p>If you just need to return a pre-defined move-only value, you can use the
<code class="docutils literal notranslate"><span class="pre">Return(ByMove(...))</span></code> action:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// When this fires, the unique_ptr&lt;&gt; specified by ByMove(...) will</span>
  <span class="c1">// be returned.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">ByMove</span><span class="p">(</span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">))));</span>

  <span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ByMove()</span></code> is essential here - if you drop it, the code won’t compile.</p>
<p>Quiz time! What do you think will happen if a <code class="docutils literal notranslate"><span class="pre">Return(ByMove(...))</span></code> action is
performed more than once (e.g. you write <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">.WillRepeatedly(Return(ByMove(...)));</span></code>)? Come think of it, after the first time
the action runs, the source value will be consumed (since it’s a move-only
value), so the next time around, there’s no value to move from – you’ll get a
run-time error that <code class="docutils literal notranslate"><span class="pre">Return(ByMove(...))</span></code> can only be run once.</p>
<p>If you need your mock method to do more than just moving a pre-defined value,
remember that you can always use a lambda or a callable object, which can do
pretty much anything you want:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">([](</span><span class="n">StringPiece</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">);</span>
      <span class="p">});</span>

  <span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">));</span>
  <span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Every time this <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> fires, a new <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code> will be created
and returned. You cannot do this with <code class="docutils literal notranslate"><span class="pre">Return(ByMove(...))</span></code>.</p>
<p>That covers returning move-only values; but how do we work with methods
accepting move-only arguments? The answer is that they work normally, although
some actions will not compile when any of method’s arguments are move-only. You
can always use <code class="docutils literal notranslate"><span class="pre">Return</span></code>, or a <a class="reference external" href="#FunctionsAsActions">lambda or functor</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Unused</span><span class="p">;</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">ShareBuzz</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span> <span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">)),</span>
              <span class="mi">0</span><span class="p">);</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">ShareBuzz</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span>
      <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span> <span class="n">buzz</span><span class="p">,</span> <span class="n">Unused</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buzz</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">});</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>Many built-in actions (<code class="docutils literal notranslate"><span class="pre">WithArgs</span></code>, <code class="docutils literal notranslate"><span class="pre">WithoutArgs</span></code>,<code class="docutils literal notranslate"><span class="pre">DeleteArg</span></code>, <code class="docutils literal notranslate"><span class="pre">SaveArg</span></code>, …)
could in principle support move-only arguments, but the support for this is not
implemented yet. If this is blocking you, please file a bug.</p>
<p>A few actions (e.g. <code class="docutils literal notranslate"><span class="pre">DoAll</span></code>) copy their arguments internally, so they can never
work with non-copyable objects; you’ll have to use functors instead.</p>
<div class="section" id="legacy-workarounds-for-move-only-types-legacymoveonly">
<h4>Legacy workarounds for move-only types {#LegacyMoveOnly}<a class="headerlink" href="#legacy-workarounds-for-move-only-types-legacymoveonly" title="Permalink to this headline">¶</a></h4>
<p>Support for move-only function arguments was only introduced to gMock in April
of 2017. In older code, you may encounter the following workaround for the lack
of this feature (it is no longer necessary - we’re including it just for
reference):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockBuzzer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Buzzer</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DoShareBuzz</span><span class="p">,</span> <span class="p">(</span><span class="n">Buzz</span><span class="o">*</span> <span class="n">buzz</span><span class="p">,</span> <span class="n">Time</span> <span class="n">timestamp</span><span class="p">));</span>
  <span class="kt">bool</span> <span class="nf">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span> <span class="n">buzz</span><span class="p">,</span> <span class="n">Time</span> <span class="n">timestamp</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">DoShareBuzz</span><span class="p">(</span><span class="n">buzz</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">timestamp</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The trick is to delegate the <code class="docutils literal notranslate"><span class="pre">ShareBuzz()</span></code> method to a mock method (let’s call
it <code class="docutils literal notranslate"><span class="pre">DoShareBuzz()</span></code>) that does not take move-only parameters. Then, instead of
setting expectations on <code class="docutils literal notranslate"><span class="pre">ShareBuzz()</span></code>, you set them on the <code class="docutils literal notranslate"><span class="pre">DoShareBuzz()</span></code> mock
method:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">MockBuzzer</span> <span class="n">mock_buzzer_</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span> <span class="n">DoShareBuzz</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span> <span class="n">_</span><span class="p">));</span>

  <span class="c1">// When one calls ShareBuzz() on the MockBuzzer like this, the call is</span>
  <span class="c1">// forwarded to DoShareBuzz(), which is mocked.  Therefore this statement</span>
  <span class="c1">// will trigger the above EXPECT_CALL.</span>
  <span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="making-the-compilation-faster">
<h3>Making the Compilation Faster<a class="headerlink" href="#making-the-compilation-faster" title="Permalink to this headline">¶</a></h3>
<p>Believe it or not, the <em>vast majority</em> of the time spent on compiling a mock
class is in generating its constructor and destructor, as they perform
non-trivial tasks (e.g. verification of the expectations). What’s more, mock
methods with different signatures have different types and thus their
constructors/destructors need to be generated by the compiler separately. As a
result, if you mock many different types of methods, compiling your mock class
can get really slow.</p>
<p>If you are experiencing slow compilation, you can move the definition of your
mock class’ constructor and destructor out of the class body and into a <code class="docutils literal notranslate"><span class="pre">.cc</span></code>
file. This way, even if you <code class="docutils literal notranslate"><span class="pre">#include</span></code> your mock class in N files, the compiler
only needs to generate its constructor and destructor once, resulting in a much
faster compilation.</p>
<p>Let’s illustrate the idea using an example. Here’s the definition of a mock
class before applying this recipe:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.h.</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Since we don&#39;t declare the constructor or the destructor,</span>
  <span class="c1">// the compiler will generate them in every translation unit</span>
  <span class="c1">// where this mock class is used.</span>

  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span> <span class="n">more</span> <span class="n">mock</span> <span class="n">methods</span> <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>After the change, it would look like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.h.</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// The constructor and destructor are declared, but not defined, here.</span>
  <span class="n">MockFoo</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">MockFoo</span><span class="p">();</span>

  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="p">...</span> <span class="n">more</span> <span class="n">mock</span> <span class="n">methods</span> <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.cc.</span>
<span class="cp">#include</span> <span class="cpf">&quot;path/to/mock_foo.h&quot;</span><span class="cp"></span>

<span class="c1">// The definitions may appear trivial, but the functions actually do a</span>
<span class="c1">// lot of things through the constructors/destructors of the member</span>
<span class="c1">// variables used to implement the mock methods.</span>
<span class="n">MockFoo</span><span class="o">::</span><span class="n">MockFoo</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">MockFoo</span><span class="o">::~</span><span class="n">MockFoo</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="forcing-a-verification">
<h3>Forcing a Verification<a class="headerlink" href="#forcing-a-verification" title="Permalink to this headline">¶</a></h3>
<p>When it’s being destroyed, your friendly mock object will automatically verify
that all expectations on it have been satisfied, and will generate googletest
failures if not. This is convenient as it leaves you with one less thing to
worry about. That is, unless you are not sure if your mock object will be
destroyed.</p>
<p>How could it be that your mock object won’t eventually be destroyed? Well, it
might be created on the heap and owned by the code you are testing. Suppose
there’s a bug in that code and it doesn’t delete the mock object properly - you
could end up with a passing test when there’s actually a bug.</p>
<p>Using a heap checker is a good idea and can alleviate the concern, but its
implementation is not 100% reliable. So, sometimes you do want to <em>force</em> gMock
to verify a mock object before it is (hopefully) destructed. You can do this
with <code class="docutils literal notranslate"><span class="pre">Mock::VerifyAndClearExpectations(&amp;mock_object)</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">MyServerTest</span><span class="p">,</span> <span class="n">ProcessesRequest</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Mock</span><span class="p">;</span>

  <span class="n">MockFoo</span><span class="o">*</span> <span class="k">const</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MockFoo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="p">...)...;</span>
  <span class="c1">// ... other expectations ...</span>

  <span class="c1">// server now owns foo.</span>
  <span class="n">MyServer</span> <span class="nf">server</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
  <span class="n">server</span><span class="p">.</span><span class="n">ProcessRequest</span><span class="p">(...);</span>

  <span class="c1">// In case that server&#39;s destructor will forget to delete foo,</span>
  <span class="c1">// this will verify the expectations anyway.</span>
  <span class="n">Mock</span><span class="o">::</span><span class="n">VerifyAndClearExpectations</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>  <span class="c1">// server is destroyed when it goes out of scope here.</span>
</pre></div>
</div>
<p>{: .callout .tip}
<strong>Tip:</strong> The <code class="docutils literal notranslate"><span class="pre">Mock::VerifyAndClearExpectations()</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">bool</span></code> to
indicate whether the verification was successful (<code class="docutils literal notranslate"><span class="pre">true</span></code> for yes), so you can
wrap that function call inside a <code class="docutils literal notranslate"><span class="pre">ASSERT_TRUE()</span></code> if there is no point going
further when the verification has failed.</p>
<p>Do not set new expectations after verifying and clearing a mock after its use.
Setting expectations after code that exercises the mock has undefined behavior.
See <a class="reference internal" href="gmock_for_dummies.html#using-mocks-in-tests"><span class="std std-ref">Using Mocks in Tests</span></a> for more
information.</p>
</div>
<div class="section" id="using-checkpoints-usingcheckpoints">
<h3>Using Checkpoints {#UsingCheckPoints}<a class="headerlink" href="#using-checkpoints-usingcheckpoints" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you might want to test a mock object’s behavior in phases whose sizes
are each manageable, or you might want to set more detailed expectations about
which API calls invoke which mock functions.</p>
<p>A technique you can use is to put the expectations in a sequence and insert
calls to a dummy “checkpoint” function at specific places. Then you can verify
that the mock function calls do happen at the right time. For example, if you
are exercising the code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>and want to verify that <code class="docutils literal notranslate"><span class="pre">Foo(1)</span></code> and <code class="docutils literal notranslate"><span class="pre">Foo(3)</span></code> both invoke <code class="docutils literal notranslate"><span class="pre">mock.Bar(&quot;a&quot;)</span></code>, but
<code class="docutils literal notranslate"><span class="pre">Foo(2)</span></code> doesn’t invoke anything, you can write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MockFunction</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span> <span class="n">InvokesBarCorrectly</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyMock</span> <span class="n">mock</span><span class="p">;</span>
  <span class="c1">// Class MockFunction&lt;F&gt; has exactly one mock method.  It is named</span>
  <span class="c1">// Call() and has type F.</span>
  <span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">string</span> <span class="n">check_point_name</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">check</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">InSequence</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">check</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">check</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The expectation spec says that the first <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> call must happen before
checkpoint “1”, the second <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> call must happen after checkpoint “2”, and
nothing should happen between the two checkpoints. The explicit checkpoints make
it clear which <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> is called by which call to <code class="docutils literal notranslate"><span class="pre">Foo()</span></code>.</p>
</div>
<div class="section" id="mocking-destructors">
<h3>Mocking Destructors<a class="headerlink" href="#mocking-destructors" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to make sure a mock object is destructed at the right time,
e.g. after <code class="docutils literal notranslate"><span class="pre">bar-&gt;A()</span></code> is called but before <code class="docutils literal notranslate"><span class="pre">bar-&gt;B()</span></code> is called. We already know
that you can specify constraints on the <a class="reference external" href="#OrderedCalls">order</a> of mock function
calls, so all we need to do is to mock the destructor of the mock function.</p>
<p>This sounds simple, except for one problem: a destructor is a special function
with special syntax and special semantics, and the <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> macro doesn’t
work for it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="o">~</span><span class="n">MockFoo</span><span class="p">,</span> <span class="p">());</span>  <span class="c1">// Won&#39;t compile!</span>
</pre></div>
</div>
<p>The good news is that you can use a simple pattern to achieve the same effect.
First, add a mock function <code class="docutils literal notranslate"><span class="pre">Die()</span></code> to your mock class and call it in the
destructor, like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Add the following two lines to the mock class.</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">Die</span><span class="p">,</span> <span class="p">());</span>
  <span class="o">~</span><span class="n">MockFoo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">Die</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(If the name <code class="docutils literal notranslate"><span class="pre">Die()</span></code> clashes with an existing symbol, choose another name.) Now,
we have translated the problem of testing when a <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> object dies to
testing when its <code class="docutils literal notranslate"><span class="pre">Die()</span></code> method is called:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">MockFoo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MockFoo</span><span class="p">;</span>
  <span class="n">MockBar</span><span class="o">*</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MockBar</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">{</span>
    <span class="n">InSequence</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">// Expects *foo to die after bar-&gt;A() and before bar-&gt;B().</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="n">A</span><span class="p">());</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="n">Die</span><span class="p">());</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="n">B</span><span class="p">());</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>And that’s that.</p>
</div>
<div class="section" id="using-gmock-and-threads-usingthreads">
<h3>Using gMock and Threads {#UsingThreads}<a class="headerlink" href="#using-gmock-and-threads-usingthreads" title="Permalink to this headline">¶</a></h3>
<p>In a <strong>unit</strong> test, it’s best if you could isolate and test a piece of code in a
single-threaded context. That avoids race conditions and dead locks, and makes
debugging your test much easier.</p>
<p>Yet most programs are multi-threaded, and sometimes to test something we need to
pound on it from more than one thread. gMock works for this purpose too.</p>
<p>Remember the steps for using a mock:</p>
<ol class="simple">
<li><p>Create a mock object <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p></li>
<li><p>Set its default actions and expectations using <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> and
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>.</p></li>
<li><p>The code under test calls methods of <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p></li>
<li><p>Optionally, verify and reset the mock.</p></li>
<li><p>Destroy the mock yourself, or let the code under test destroy it. The
destructor will automatically verify it.</p></li>
</ol>
<p>If you follow the following simple rules, your mocks and threads can live
happily together:</p>
<ul class="simple">
<li><p>Execute your <em>test code</em> (as opposed to the code being tested) in <em>one</em>
thread. This makes your test easy to follow.</p></li>
<li><p>Obviously, you can do step #1 without locking.</p></li>
<li><p>When doing step #2 and #5, make sure no other thread is accessing <code class="docutils literal notranslate"><span class="pre">foo</span></code>.
Obvious too, huh?</p></li>
<li><p>#3 and #4 can be done either in one thread or in multiple threads - anyway
you want. gMock takes care of the locking, so you don’t have to do any -
unless required by your test logic.</p></li>
</ul>
<p>If you violate the rules (for example, if you set expectations on a mock while
another thread is calling its methods), you get undefined behavior. That’s not
fun, so don’t do it.</p>
<p>gMock guarantees that the action for a mock function is done in the same thread
that called the mock function. For example, in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action1</span><span class="p">);</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action2</span><span class="p">);</span>
</pre></div>
</div>
<p>if <code class="docutils literal notranslate"><span class="pre">Foo(1)</span></code> is called in thread 1 and <code class="docutils literal notranslate"><span class="pre">Foo(2)</span></code> is called in thread 2, gMock will
execute <code class="docutils literal notranslate"><span class="pre">action1</span></code> in thread 1 and <code class="docutils literal notranslate"><span class="pre">action2</span></code> in thread 2.</p>
<p>gMock does <em>not</em> impose a sequence on actions performed in different threads
(doing so may create deadlocks as the actions may need to cooperate). This means
that the execution of <code class="docutils literal notranslate"><span class="pre">action1</span></code> and <code class="docutils literal notranslate"><span class="pre">action2</span></code> in the above example <em>may</em>
interleave. If this is a problem, you should add proper synchronization logic to
<code class="docutils literal notranslate"><span class="pre">action1</span></code> and <code class="docutils literal notranslate"><span class="pre">action2</span></code> to make the test thread-safe.</p>
<p>Also, remember that <code class="docutils literal notranslate"><span class="pre">DefaultValue&lt;T&gt;</span></code> is a global resource that potentially
affects <em>all</em> living mock objects in your program. Naturally, you won’t want to
mess with it from multiple threads or when there still are mocks in action.</p>
</div>
<div class="section" id="controlling-how-much-information-gmock-prints">
<h3>Controlling How Much Information gMock Prints<a class="headerlink" href="#controlling-how-much-information-gmock-prints" title="Permalink to this headline">¶</a></h3>
<p>When gMock sees something that has the potential of being an error (e.g. a mock
function with no expectation is called, a.k.a. an uninteresting call, which is
allowed but perhaps you forgot to explicitly ban the call), it prints some
warning messages, including the arguments of the function, the return value, and
the stack trace. Hopefully this will remind you to take a look and see if there
is indeed a problem.</p>
<p>Sometimes you are confident that your tests are correct and may not appreciate
such friendly messages. Some other times, you are debugging your tests or
learning about the behavior of the code you are testing, and wish you could
observe every mock call that happens (including argument values, the return
value, and the stack trace). Clearly, one size doesn’t fit all.</p>
<p>You can control how much gMock tells you using the <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=LEVEL</span></code>
command-line flag, where <code class="docutils literal notranslate"><span class="pre">LEVEL</span></code> is a string with three possible values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">info</span></code>: gMock will print all informational messages, warnings, and errors
(most verbose). At this setting, gMock will also log any calls to the
<code class="docutils literal notranslate"><span class="pre">ON_CALL/EXPECT_CALL</span></code> macros. It will include a stack trace in
“uninteresting call” warnings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warning</span></code>: gMock will print both warnings and errors (less verbose); it will
omit the stack traces in “uninteresting call” warnings. This is the default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: gMock will print errors only (least verbose).</p></li>
</ul>
<p>Alternatively, you can adjust the value of that flag from within your tests like
so:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">FLAGS_gmock_verbose</span> <span class="o">=</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>If you find gMock printing too many stack frames with its informational or
warning messages, remember that you can control their amount with the
<code class="docutils literal notranslate"><span class="pre">--gtest_stack_trace_depth=max_depth</span></code> flag.</p>
<p>Now, judiciously use the right flag to enable gMock serve you better!</p>
</div>
<div class="section" id="gaining-super-vision-into-mock-calls">
<h3>Gaining Super Vision into Mock Calls<a class="headerlink" href="#gaining-super-vision-into-mock-calls" title="Permalink to this headline">¶</a></h3>
<p>You have a test using gMock. It fails: gMock tells you some expectations aren’t
satisfied. However, you aren’t sure why: Is there a typo somewhere in the
matchers? Did you mess up the order of the <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s? Or is the code under
test doing something wrong? How can you find out the cause?</p>
<p>Won’t it be nice if you have X-ray vision and can actually see the trace of all
<code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>s and mock method calls as they are made? For each call, would you
like to see its actual argument values and which <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> gMock thinks it
matches? If you still need some help to figure out who made these calls, how
about being able to see the complete stack trace at each mock call?</p>
<p>You can unlock this power by running your test with the <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code>
flag. For example, given the test program:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;gmock/gmock.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">HasSubstr</span><span class="p">;</span>
<span class="k">using</span> <span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MockFoo</span> <span class="n">mock</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">F</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)).</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">());</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">));</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">F</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="n">HasSubstr</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)));</span>

  <span class="n">mock</span><span class="p">.</span><span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;good&quot;</span><span class="p">);</span>
  <span class="n">mock</span><span class="p">.</span><span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>if you run it with <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code>, you will see this output:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>[ RUN       ] Foo.Bar

foo_test.cc:14: EXPECT_CALL(mock, F(_, _)) invoked
Stack trace: ...

foo_test.cc:15: EXPECT_CALL(mock, F(&quot;a&quot;, &quot;b&quot;)) invoked
Stack trace: ...

foo_test.cc:16: EXPECT_CALL(mock, F(&quot;c&quot;, HasSubstr(&quot;d&quot;))) invoked
Stack trace: ...

foo_test.cc:14: Mock function call matches EXPECT_CALL(mock, F(_, _))...
    Function call: F(@0x7fff7c8dad40&quot;a&quot;,@0x7fff7c8dad10&quot;good&quot;)
Stack trace: ...

foo_test.cc:15: Mock function call matches EXPECT_CALL(mock, F(&quot;a&quot;, &quot;b&quot;))...
    Function call: F(@0x7fff7c8dada0&quot;a&quot;,@0x7fff7c8dad70&quot;b&quot;)
Stack trace: ...

foo_test.cc:16: Failure
Actual function call count doesn&#39;t match EXPECT_CALL(mock, F(&quot;c&quot;, HasSubstr(&quot;d&quot;)))...
         Expected: to be called once
           Actual: never called - unsatisfied and active
[  FAILED  ] Foo.Bar
</pre></div>
</div>
<p>Suppose the bug is that the <code class="docutils literal notranslate"><span class="pre">&quot;c&quot;</span></code> in the third <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> is a typo and
should actually be <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>. With the above message, you should see that the actual
<code class="docutils literal notranslate"><span class="pre">F(&quot;a&quot;,</span> <span class="pre">&quot;good&quot;)</span></code> call is matched by the first <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, not the third as
you thought. From that it should be obvious that the third <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> is
written wrong. Case solved.</p>
<p>If you are interested in the mock call trace but not the stack traces, you can
combine <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code> with <code class="docutils literal notranslate"><span class="pre">--gtest_stack_trace_depth=0</span></code> on the test
command line.</p>
</div>
<div class="section" id="running-tests-in-emacs">
<h3>Running Tests in Emacs<a class="headerlink" href="#running-tests-in-emacs" title="Permalink to this headline">¶</a></h3>
<p>If you build and run your tests in Emacs using the <code class="docutils literal notranslate"><span class="pre">M-x</span> <span class="pre">google-compile</span></code> command
(as many googletest users do), the source file locations of gMock and googletest
errors will be highlighted. Just press <code class="docutils literal notranslate"><span class="pre">&lt;Enter&gt;</span></code> on one of them and you’ll be
taken to the offending line. Or, you can just type `C-x`` to jump to the next
error.</p>
<p>To make it even easier, you can add the following lines to your <code class="docutils literal notranslate"><span class="pre">~/.emacs</span></code> file:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(global-set-key &quot;\M-m&quot;  &#39;google-compile)  ; m is for make
(global-set-key [M-down] &#39;next-error)
(global-set-key [M-up]  &#39;(lambda () (interactive) (next-error -1)))
</pre></div>
</div>
<p>Then you can type <code class="docutils literal notranslate"><span class="pre">M-m</span></code> to start a build (if you want to run the test as well,
just make sure <code class="docutils literal notranslate"><span class="pre">foo_test.run</span></code> or <code class="docutils literal notranslate"><span class="pre">runtests</span></code> is in the build command you supply
after typing <code class="docutils literal notranslate"><span class="pre">M-m</span></code>), or <code class="docutils literal notranslate"><span class="pre">M-up</span></code>/<code class="docutils literal notranslate"><span class="pre">M-down</span></code> to move back and forth between errors.</p>
</div>
</div>
<div class="section" id="extending-gmock">
<h2>Extending gMock<a class="headerlink" href="#extending-gmock" title="Permalink to this headline">¶</a></h2>
<div class="section" id="writing-new-matchers-quickly-newmatchers">
<h3>Writing New Matchers Quickly {#NewMatchers}<a class="headerlink" href="#writing-new-matchers-quickly-newmatchers" title="Permalink to this headline">¶</a></h3>
<p>{: .callout .warning}
WARNING: gMock does not guarantee when or how many times a matcher will be
invoked. Therefore, all matchers must be functionally pure. See
<a class="reference external" href="#PureMatchers">this section</a> for more details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MATCHER*</span></code> family of macros can be used to define custom matchers easily.
The syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">description_string_expression</span><span class="p">)</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>will define a matcher with the given name that executes the statements, which
must return a <code class="docutils literal notranslate"><span class="pre">bool</span></code> to indicate if the match succeeds. Inside the statements,
you can refer to the value being matched by <code class="docutils literal notranslate"><span class="pre">arg</span></code>, and refer to its type by
<code class="docutils literal notranslate"><span class="pre">arg_type</span></code>.</p>
<p>The <em>description string</em> is a <code class="docutils literal notranslate"><span class="pre">string</span></code>-typed expression that documents what the
matcher does, and is used to generate the failure message when the match fails.
It can (and should) reference the special <code class="docutils literal notranslate"><span class="pre">bool</span></code> variable <code class="docutils literal notranslate"><span class="pre">negation</span></code>, and should
evaluate to the description of the matcher when <code class="docutils literal notranslate"><span class="pre">negation</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, or that
of the matcher’s negation when <code class="docutils literal notranslate"><span class="pre">negation</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>For convenience, we allow the description string to be empty (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>), in which
case gMock will use the sequence of words in the matcher name as the
description.</p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">arg</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>allows you to write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Expects mock_foo.Bar(n) to be called where n is divisible by 7.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>or,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Not</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="c1">// Verifies that a value is divisible by 7 and the other is not.</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">some_expression</span><span class="p">,</span> <span class="n">IsDivisibleBy7</span><span class="p">());</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">some_other_expression</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>If the above assertions fail, they will print something like:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  Value of: some_expression
  Expected: is divisible by <span class="m">7</span>
    Actual: <span class="m">27</span>
  ...
  Value of: some_other_expression
  Expected: not <span class="o">(</span>is divisible by <span class="m">7</span><span class="o">)</span>
    Actual: <span class="m">21</span>
</pre></div>
</div>
<p>where the descriptions <code class="docutils literal notranslate"><span class="pre">&quot;is</span> <span class="pre">divisible</span> <span class="pre">by</span> <span class="pre">7&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;not</span> <span class="pre">(is</span> <span class="pre">divisible</span> <span class="pre">by</span> <span class="pre">7)&quot;</span></code> are
automatically calculated from the matcher name <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7</span></code>.</p>
<p>As you may have noticed, the auto-generated descriptions (especially those for
the negation) may not be so great. You can always override them with a <code class="docutils literal notranslate"><span class="pre">string</span></code>
expression of your own:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span>
        <span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="n">negation</span> <span class="o">?</span> <span class="s">&quot;isn&#39;t&quot;</span> <span class="o">:</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot; divisible by 7&quot;</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">arg</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Optionally, you can stream additional information to a hidden argument named
<code class="docutils literal notranslate"><span class="pre">result_listener</span></code> to explain the match result. For example, a better definition
of <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7</span></code> is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="o">*</span><span class="n">result_listener</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;the remainder is &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">arg</span> <span class="o">%</span> <span class="mi">7</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this definition, the above assertion will give a better message:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  Value of: some_expression
  Expected: is divisible by <span class="m">7</span>
    Actual: <span class="m">27</span> <span class="o">(</span>the remainder is <span class="m">6</span><span class="o">)</span>
</pre></div>
</div>
<p>You should let <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code> print <em>any additional information</em> that can
help a user understand the match result. Note that it should explain why the
match succeeds in case of a success (unless it’s obvious) - this is useful when
the matcher is used inside <code class="docutils literal notranslate"><span class="pre">Not()</span></code>. There is no need to print the argument value
itself, as gMock already prints it for you.</p>
<p>{: .callout .note}
NOTE: The type of the value being matched (<code class="docutils literal notranslate"><span class="pre">arg_type</span></code>) is determined by the
context in which you use the matcher and is supplied to you by the compiler, so
you don’t need to worry about declaring it (nor can you). This allows the
matcher to be polymorphic. For example, <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7()</span></code> can be used to match
any type where the value of <code class="docutils literal notranslate"><span class="pre">(arg</span> <span class="pre">%</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code> can be implicitly converted to a
<code class="docutils literal notranslate"><span class="pre">bool</span></code>. In the <code class="docutils literal notranslate"><span class="pre">Bar(IsDivisibleBy7())</span></code> example above, if method <code class="docutils literal notranslate"><span class="pre">Bar()</span></code> takes an
<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> will be <code class="docutils literal notranslate"><span class="pre">int</span></code>; if it takes an <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> will
be <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>; and so on.</p>
</div>
<div class="section" id="writing-new-parameterized-matchers-quickly">
<h3>Writing New Parameterized Matchers Quickly<a class="headerlink" href="#writing-new-parameterized-matchers-quickly" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you’ll want to define a matcher that has parameters. For that you can
use the macro:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">description_string</span><span class="p">)</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the description string can be either <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> or a <code class="docutils literal notranslate"><span class="pre">string</span></code> expression that
references <code class="docutils literal notranslate"><span class="pre">negation</span></code> and <code class="docutils literal notranslate"><span class="pre">param_name</span></code>.</p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">HasAbsoluteValue</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>will allow you to write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">Blah</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="n">HasAbsoluteValue</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
</pre></div>
</div>
<p>which may lead to this message (assuming <code class="docutils literal notranslate"><span class="pre">n</span></code> is 10):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  Value of: Blah<span class="o">(</span><span class="s2">&quot;a&quot;</span><span class="o">)</span>
  Expected: has absolute value <span class="m">10</span>
    Actual: -9
</pre></div>
</div>
<p>Note that both the matcher description and its parameter are printed, making the
message human-friendly.</p>
<p>In the matcher definition body, you can write <code class="docutils literal notranslate"><span class="pre">foo_type</span></code> to reference the type
of a parameter named <code class="docutils literal notranslate"><span class="pre">foo</span></code>. For example, in the body of
<code class="docutils literal notranslate"><span class="pre">MATCHER_P(HasAbsoluteValue,</span> <span class="pre">value)</span></code> above, you can write <code class="docutils literal notranslate"><span class="pre">value_type</span></code> to refer
to the type of <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>gMock also provides <code class="docutils literal notranslate"><span class="pre">MATCHER_P2</span></code>, <code class="docutils literal notranslate"><span class="pre">MATCHER_P3</span></code>, …, up to <code class="docutils literal notranslate"><span class="pre">MATCHER_P10</span></code> to
support multi-parameter matchers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_Pk</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param_1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">param_k</span><span class="p">,</span> <span class="n">description_string</span><span class="p">)</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Please note that the custom description string is for a particular <em>instance</em> of
the matcher, where the parameters have been bound to actual values. Therefore
usually you’ll want the parameter values to be part of the description. gMock
lets you do that by referencing the matcher parameters in the description string
expression.</p>
<p>For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PrintToString</span><span class="p">;</span>
<span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">InClosedRange</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span>
           <span class="n">absl</span><span class="o">::</span><span class="n">StrFormat</span><span class="p">(</span><span class="s">&quot;%s in range [%s, %s]&quot;</span><span class="p">,</span> <span class="n">negation</span> <span class="o">?</span> <span class="s">&quot;isn&#39;t&quot;</span> <span class="o">:</span> <span class="s">&quot;is&quot;</span><span class="p">,</span>
                           <span class="n">PrintToString</span><span class="p">(</span><span class="n">low</span><span class="p">),</span> <span class="n">PrintToString</span><span class="p">(</span><span class="n">hi</span><span class="p">)))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">arg</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">EXPECT_THAT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">InClosedRange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
</pre></div>
</div>
<p>would generate a failure that contains the message:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  Expected: is in range <span class="o">[</span><span class="m">4</span>, <span class="m">6</span><span class="o">]</span>
</pre></div>
</div>
<p>If you specify <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> as the description, the failure message will contain the
sequence of words in the matcher name followed by the parameter values printed
as a tuple. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">InClosedRange</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">InClosedRange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span>
</pre></div>
</div>
<p>would generate a failure that contains the text:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  Expected: in closed range <span class="o">(</span><span class="m">4</span>, <span class="m">6</span><span class="o">)</span>
</pre></div>
</div>
<p>For the purpose of typing, you can view</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_Pk</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">description_string</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>as shorthand for</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">p1_type</span><span class="p">,</span> <span class="p">...,</span> <span class="k">typename</span> <span class="n">pk_type</span><span class="o">&gt;</span>
<span class="n">FooMatcherPk</span><span class="o">&lt;</span><span class="n">p1_type</span><span class="p">,</span> <span class="p">...,</span> <span class="n">pk_type</span><span class="o">&gt;</span>
<span class="n">Foo</span><span class="p">(</span><span class="n">p1_type</span> <span class="n">p1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">pk_type</span> <span class="n">pk</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>When you write <code class="docutils literal notranslate"><span class="pre">Foo(v1,</span> <span class="pre">...,</span> <span class="pre">vk)</span></code>, the compiler infers the types of the
parameters <code class="docutils literal notranslate"><span class="pre">v1</span></code>, …, and <code class="docutils literal notranslate"><span class="pre">vk</span></code> for you. If you are not happy with the result of
the type inference, you can specify the types by explicitly instantiating the
template, as in <code class="docutils literal notranslate"><span class="pre">Foo&lt;long,</span> <span class="pre">bool&gt;(5,</span> <span class="pre">false)</span></code>. As said earlier, you don’t get to
(or need to) specify <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> as that’s determined by the context in which the
matcher is used.</p>
<p>You can assign the result of expression <code class="docutils literal notranslate"><span class="pre">Foo(p1,</span> <span class="pre">...,</span> <span class="pre">pk)</span></code> to a variable of type
<code class="docutils literal notranslate"><span class="pre">FooMatcherPk&lt;p1_type,</span> <span class="pre">...,</span> <span class="pre">pk_type&gt;</span></code>. This can be useful when composing
matchers. Matchers that don’t have a parameter or have only one parameter have
special types: you can assign <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> to a <code class="docutils literal notranslate"><span class="pre">FooMatcher</span></code>-typed variable, and
assign <code class="docutils literal notranslate"><span class="pre">Foo(p)</span></code> to a <code class="docutils literal notranslate"><span class="pre">FooMatcherP&lt;p_type&gt;</span></code>-typed variable.</p>
<p>While you can instantiate a matcher template with reference types, passing the
parameters by pointer usually makes your code more readable. If, however, you
still want to pass a parameter by reference, be aware that in the failure
message generated by the matcher you will see the value of the referenced object
but not its address.</p>
<p>You can overload matchers with different numbers of parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">Blah</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">description_string_1</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">Blah</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">description_string_2</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>While it’s tempting to always use the <code class="docutils literal notranslate"><span class="pre">MATCHER*</span></code> macros when defining a new
matcher, you should also consider implementing the matcher interface directly
instead (see the recipes that follow), especially if you need to use the matcher
a lot. While these approaches require more work, they give you more control on
the types of the value being matched and the matcher parameters, which in
general leads to better compiler error messages that pay off in the long run.
They also allow overloading matchers based on parameter types (as opposed to
just based on the number of parameters).</p>
</div>
<div class="section" id="writing-new-monomorphic-matchers">
<h3>Writing New Monomorphic Matchers<a class="headerlink" href="#writing-new-monomorphic-matchers" title="Permalink to this headline">¶</a></h3>
<p>A matcher of argument type <code class="docutils literal notranslate"><span class="pre">T</span></code> implements the matcher interface for <code class="docutils literal notranslate"><span class="pre">T</span></code> and does
two things: it tests whether a value of type <code class="docutils literal notranslate"><span class="pre">T</span></code> matches the matcher, and can
describe what kind of values it matches. The latter ability is used for
generating readable error messages when expectations are violated.</p>
<p>A matcher of <code class="docutils literal notranslate"><span class="pre">T</span></code> must declare a typedef like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">is_gtest_matcher</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>
</pre></div>
</div>
<p>and supports the following operations:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Match a value and optionally explain into an ostream.</span>
<span class="kt">bool</span> <span class="n">matched</span> <span class="o">=</span> <span class="n">matcher</span><span class="p">.</span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">maybe_os</span><span class="p">);</span>
<span class="c1">// where `value` is of type `T` and</span>
<span class="c1">// `maybe_os` is of type `std::ostream*`, where it can be null if the caller</span>
<span class="c1">// is not interested in there textual explanation.</span>

<span class="n">matcher</span><span class="p">.</span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="n">matcher</span><span class="p">.</span><span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="c1">// where `os` is of type `std::ostream*`.</span>
</pre></div>
</div>
<p>If you need a custom matcher but <code class="docutils literal notranslate"><span class="pre">Truly()</span></code> is not a good option (for example,
you may not be happy with the way <code class="docutils literal notranslate"><span class="pre">Truly(predicate)</span></code> describes itself, or you
may want your matcher to be polymorphic as <code class="docutils literal notranslate"><span class="pre">Eq(value)</span></code> is), you can define a
matcher to do whatever you want in two steps: first implement the matcher
interface, and then define a factory function to create a matcher instance. The
second step is not strictly needed but it makes the syntax of using the matcher
nicer.</p>
<p>For example, you can define a matcher to test whether an <code class="docutils literal notranslate"><span class="pre">int</span></code> is divisible by 7
and then use it like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DivisibleBy7Matcher</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">is_gtest_matcher</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">MatchAndExplain</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is divisible by 7&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is not divisible by 7&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">DivisibleBy7</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">DivisibleBy7Matcher</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">DivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>You may improve the matcher message by streaming additional information to the
<code class="docutils literal notranslate"><span class="pre">os</span></code> argument in <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DivisibleBy7Matcher</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">MatchAndExplain</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">os</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;the remainder is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">remainder</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">EXPECT_THAT(x,</span> <span class="pre">DivisibleBy7());</span></code> may generate a message like this:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Value of: x
Expected: is divisible by <span class="m">7</span>
  Actual: <span class="m">23</span> <span class="o">(</span>the remainder is <span class="m">2</span><span class="o">)</span>
</pre></div>
</div>
<p>{: .callout .tip}
Tip: for convenience, <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code> can take a <code class="docutils literal notranslate"><span class="pre">MatchResultListener*</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">std::ostream*</span></code>.</p>
</div>
<div class="section" id="writing-new-polymorphic-matchers">
<h3>Writing New Polymorphic Matchers<a class="headerlink" href="#writing-new-polymorphic-matchers" title="Permalink to this headline">¶</a></h3>
<p>Expanding what we learned above to <em>polymorphic</em> matchers is now just as simple
as adding templates in the right place.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NotNullMatcher</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">is_gtest_matcher</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>

  <span class="c1">// To implement a polymorphic matcher, we just need to make MatchAndExplain a</span>
  <span class="c1">// template on its first argument.</span>

  <span class="c1">// In this example, we want to use NotNull() with any pointer, so</span>
  <span class="c1">// MatchAndExplain() accepts a pointer of any type as its first argument.</span>
  <span class="c1">// In general, you can define MatchAndExplain() as an ordinary method or</span>
  <span class="c1">// a method template, or even overload it.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Describes the property of a value matching this matcher.</span>
  <span class="kt">void</span> <span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is not NULL&quot;</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Describes the property of a value NOT matching this matcher.</span>
  <span class="kt">void</span> <span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is NULL&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">NotNullMatcher</span> <span class="nf">NotNull</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">NotNullMatcher</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">NotNull</span><span class="p">()));</span>  <span class="c1">// The argument must be a non-NULL pointer.</span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-matcher-implementation">
<h3>Legacy Matcher Implementation<a class="headerlink" href="#legacy-matcher-implementation" title="Permalink to this headline">¶</a></h3>
<p>Defining matchers used to be somewhat more complicated, in which it required
several supporting classes and virtual functions. To implement a matcher for
type <code class="docutils literal notranslate"><span class="pre">T</span></code> using the legacy API you have to derive from <code class="docutils literal notranslate"><span class="pre">MatcherInterface&lt;T&gt;</span></code> and
call <code class="docutils literal notranslate"><span class="pre">MakeMatcher</span></code> to construct the object.</p>
<p>The interface looks like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MatchResultListener</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
  <span class="c1">// Streams x to the underlying ostream; does nothing if the ostream</span>
  <span class="c1">// is NULL.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">MatchResultListener</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

  <span class="c1">// Returns the underlying ostream.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">stream</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MatcherInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">MatcherInterface</span><span class="p">();</span>

  <span class="c1">// Returns true if and only if the matcher matches x; also explains the match</span>
  <span class="c1">// result to &#39;listener&#39;.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MatchAndExplain</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">MatchResultListener</span><span class="o">*</span> <span class="n">listener</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Describes this matcher to an ostream.</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Describes the negation of this matcher to an ostream.</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Fortunately, most of the time you can define a polymorphic matcher easily with
the help of <code class="docutils literal notranslate"><span class="pre">MakePolymorphicMatcher()</span></code>. Here’s how you can define <code class="docutils literal notranslate"><span class="pre">NotNull()</span></code> as
an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakePolymorphicMatcher</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MatchResultListener</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PolymorphicMatcher</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">NotNullMatcher</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// To implement a polymorphic matcher, first define a COPYABLE class</span>
  <span class="c1">// that has three members MatchAndExplain(), DescribeTo(), and</span>
  <span class="c1">// DescribeNegationTo(), like the following.</span>

  <span class="c1">// In this example, we want to use NotNull() with any pointer, so</span>
  <span class="c1">// MatchAndExplain() accepts a pointer of any type as its first argument.</span>
  <span class="c1">// In general, you can define MatchAndExplain() as an ordinary method or</span>
  <span class="c1">// a method template, or even overload it.</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span>
                       <span class="n">MatchResultListener</span><span class="o">*</span> <span class="cm">/* listener */</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Describes the property of a value matching this matcher.</span>
  <span class="kt">void</span> <span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is not NULL&quot;</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Describes the property of a value NOT matching this matcher.</span>
  <span class="kt">void</span> <span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is NULL&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// To construct a polymorphic matcher, pass an instance of the class</span>
<span class="c1">// to MakePolymorphicMatcher().  Note the return type.</span>
<span class="n">PolymorphicMatcher</span><span class="o">&lt;</span><span class="n">NotNullMatcher</span><span class="o">&gt;</span> <span class="n">NotNull</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MakePolymorphicMatcher</span><span class="p">(</span><span class="n">NotNullMatcher</span><span class="p">());</span>
<span class="p">}</span>

<span class="p">...</span>

  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="n">NotNull</span><span class="p">()));</span>  <span class="c1">// The argument must be a non-NULL pointer.</span>
</pre></div>
</div>
<p>{: .callout .note}
<strong>Note:</strong> Your polymorphic matcher class does <strong>not</strong> need to inherit from
<code class="docutils literal notranslate"><span class="pre">MatcherInterface</span></code> or any other class, and its methods do <strong>not</strong> need to be
virtual.</p>
<p>Like in a monomorphic matcher, you may explain the match result by streaming
additional information to the <code class="docutils literal notranslate"><span class="pre">listener</span></code> argument in <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code>.</p>
</div>
<div class="section" id="writing-new-cardinalities">
<h3>Writing New Cardinalities<a class="headerlink" href="#writing-new-cardinalities" title="Permalink to this headline">¶</a></h3>
<p>A cardinality is used in <code class="docutils literal notranslate"><span class="pre">Times()</span></code> to tell gMock how many times you expect a
call to occur. It doesn’t have to be exact. For example, you can say
<code class="docutils literal notranslate"><span class="pre">AtLeast(5)</span></code> or <code class="docutils literal notranslate"><span class="pre">Between(2,</span> <span class="pre">4)</span></code>.</p>
<p>If the built-in set of cardinalities
doesn’t suit you, you are free to define your own by implementing the following
interface (in namespace <code class="docutils literal notranslate"><span class="pre">testing</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CardinalityInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">CardinalityInterface</span><span class="p">();</span>

  <span class="c1">// Returns true if and only if call_count calls will satisfy this cardinality.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">IsSatisfiedByCallCount</span><span class="p">(</span><span class="kt">int</span> <span class="n">call_count</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Returns true if and only if call_count calls will saturate this</span>
  <span class="c1">// cardinality.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">IsSaturatedByCallCount</span><span class="p">(</span><span class="kt">int</span> <span class="n">call_count</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Describes self to an ostream.</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For example, to specify that a call must occur even number of times, you can
write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Cardinality</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">CardinalityInterface</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakeCardinality</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">EvenNumberCardinality</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CardinalityInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">IsSatisfiedByCallCount</span><span class="p">(</span><span class="kt">int</span> <span class="n">call_count</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">call_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">IsSaturatedByCallCount</span><span class="p">(</span><span class="kt">int</span> <span class="n">call_count</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;called even number of times&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">Cardinality</span> <span class="nf">EvenNumber</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MakeCardinality</span><span class="p">(</span><span class="k">new</span> <span class="n">EvenNumberCardinality</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
      <span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">EvenNumber</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-new-actions-quickly-quicknewactions">
<h3>Writing New Actions Quickly {#QuickNewActions}<a class="headerlink" href="#writing-new-actions-quickly-quicknewactions" title="Permalink to this headline">¶</a></h3>
<p>If the built-in actions don’t work for you, you can easily define your own one.
Just define a functor class with a (possibly templated) call operator, matching
the signature of your action.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Increment</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same approach works with stateful functors (or any callable, really):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">MultiplyBy</span> <span class="p">{</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">T</span> <span class="n">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span> <span class="p">}</span>

  <span class="nb">int</span> <span class="n">multiplier</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Then</span> <span class="n">use</span><span class="p">:</span>
<span class="o">//</span> <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">MultiplyBy</span><span class="p">{</span><span class="mi">7</span><span class="p">});</span>
</pre></div>
</div>
<div class="section" id="legacy-macro-based-actions">
<h4>Legacy macro-based Actions<a class="headerlink" href="#legacy-macro-based-actions" title="Permalink to this headline">¶</a></h4>
<p>Before C++11, the functor-based actions were not supported; the old way of
writing actions was through a set of <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> macros. We suggest to avoid them
in new code; they hide a lot of logic behind the macro, potentially leading to
harder-to-understand compiler errors. Nevertheless, we cover them here for
completeness.</p>
<p>By writing</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>in a namespace scope (i.e. not inside a class or function), you will define an
action with the given name that executes the statements. The value returned by
<code class="docutils literal notranslate"><span class="pre">statements</span></code> will be used as the return value of the action. Inside the
statements, you can refer to the K-th (0-based) argument of the mock function as
<code class="docutils literal notranslate"><span class="pre">argK</span></code>. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">IncrementArg1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">arg1</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>allows you to write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span> <span class="n">WillOnce</span><span class="p">(</span><span class="n">IncrementArg1</span><span class="p">());</span>
</pre></div>
</div>
<p>Note that you don’t need to specify the types of the mock function arguments.
Rest assured that your code is type-safe though: you’ll get a compiler error if
<code class="docutils literal notranslate"><span class="pre">*arg1</span></code> doesn’t support the <code class="docutils literal notranslate"><span class="pre">++</span></code> operator, or if the type of <code class="docutils literal notranslate"><span class="pre">++(*arg1)</span></code> isn’t
compatible with the mock function’s return type.</p>
<p>Another example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="n">arg2</span><span class="p">)(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">Blah</span><span class="p">();</span>
  <span class="o">*</span><span class="n">arg1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">arg0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>defines an action <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> that invokes argument #2 (a function pointer) with 5,
calls function <code class="docutils literal notranslate"><span class="pre">Blah()</span></code>, sets the value pointed to by argument #1 to 0, and
returns argument #0.</p>
<p>For more convenience and flexibility, you can also use the following pre-defined
symbols in the body of <code class="docutils literal notranslate"><span class="pre">ACTION</span></code>:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th align="left"><code>argK_type</code></th>
<th align="left">The type of the K-th (0-based) argument of the mock function</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>args</code></td>
<td align="left">All arguments of the mock function as a tuple</td>
</tr>
<tr>
<td align="left"><code>args_type</code></td>
<td align="left">The type of all arguments of the mock function as a tuple</td>
</tr>
<tr>
<td align="left"><code>return_type</code></td>
<td align="left">The return type of the mock function</td>
</tr>
<tr>
<td align="left"><code>function_type</code></td>
<td align="left">The type of the mock function</td>
</tr>
</tbody>
</table><p>For example, when using an <code class="docutils literal notranslate"><span class="pre">ACTION</span></code> as a stub action for mock function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">DoSomething</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>we have:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Pre-defined Symbol</th>
<th>Is Bound To</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arg0</code></td>
<td>the value of <code>flag</code></td>
</tr>
<tr>
<td><code>arg0_type</code></td>
<td>the type <code>bool</code></td>
</tr>
<tr>
<td><code>arg1</code></td>
<td>the value of <code>ptr</code></td>
</tr>
<tr>
<td><code>arg1_type</code></td>
<td>the type <code>int*</code></td>
</tr>
<tr>
<td><code>args</code></td>
<td>the tuple <code>(flag, ptr)</code></td>
</tr>
<tr>
<td><code>args_type</code></td>
<td>the type <code>std::tuple&lt;bool, int*&gt;</code></td>
</tr>
<tr>
<td><code>return_type</code></td>
<td>the type <code>int</code></td>
</tr>
<tr>
<td><code>function_type</code></td>
<td>the type <code>int(bool, int*)</code></td>
</tr>
</tbody>
</table></div>
<div class="section" id="legacy-macro-based-parameterized-actions">
<h4>Legacy macro-based parameterized Actions<a class="headerlink" href="#legacy-macro-based-parameterized-actions" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you’ll want to parameterize an action you define. For that we have
another macro</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arg0</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>will allow you to write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns argument #0 + 5.</span>
<span class="p">...</span> <span class="n">WillOnce</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>For convenience, we use the term <em>arguments</em> for the values used to invoke the
mock function, and the term <em>parameters</em> for the values used to instantiate an
action.</p>
<p>Note that you don’t need to provide the type of the parameter either. Suppose
the parameter is named <code class="docutils literal notranslate"><span class="pre">param</span></code>, you can also use the gMock-defined symbol
<code class="docutils literal notranslate"><span class="pre">param_type</span></code> to refer to the type of the parameter as inferred by the compiler.
For example, in the body of <code class="docutils literal notranslate"><span class="pre">ACTION_P(Add,</span> <span class="pre">n)</span></code> above, you can write <code class="docutils literal notranslate"><span class="pre">n_type</span></code> for
the type of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>gMock also provides <code class="docutils literal notranslate"><span class="pre">ACTION_P2</span></code>, <code class="docutils literal notranslate"><span class="pre">ACTION_P3</span></code>, and etc to support multi-parameter
actions. For example,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P2</span><span class="p">(</span><span class="n">ReturnDistanceTo</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">arg0</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>lets you write</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span> <span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnDistanceTo</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">26.5</span><span class="p">));</span>
</pre></div>
</div>
<p>You can view <code class="docutils literal notranslate"><span class="pre">ACTION</span></code> as a degenerated parameterized action where the number of
parameters is 0.</p>
<p>You can also easily define actions overloaded on the number of parameters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">Plus</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="n">ACTION_P2</span><span class="p">(</span><span class="n">Plus</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="restricting-the-type-of-an-argument-or-parameter-in-an-action">
<h3>Restricting the Type of an Argument or Parameter in an ACTION<a class="headerlink" href="#restricting-the-type-of-an-argument-or-parameter-in-an-action" title="Permalink to this headline">¶</a></h3>
<p>For maximum brevity and reusability, the <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> macros don’t ask you to
provide the types of the mock function arguments and the action parameters.
Instead, we let the compiler infer the types for us.</p>
<p>Sometimes, however, we may want to be more explicit about the types. There are
several tricks to do that. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Makes sure arg0 can be converted to int.</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">arg0</span><span class="p">;</span>
  <span class="p">...</span> <span class="n">use</span> <span class="n">n</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">arg0</span> <span class="n">here</span> <span class="p">...</span>
<span class="p">}</span>

<span class="n">ACTION_P</span><span class="p">(</span><span class="n">Bar</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Makes sure the type of arg1 is const char*.</span>
  <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StaticAssertTypeEq</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">arg1_type</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Makes sure param can be converted to bool.</span>
  <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">StaticAssertTypeEq</span></code> is a compile-time assertion in googletest that
verifies two types are the same.</p>
</div>
<div class="section" id="writing-new-action-templates-quickly">
<h3>Writing New Action Templates Quickly<a class="headerlink" href="#writing-new-action-templates-quickly" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to give an action explicit template parameters that cannot be
inferred from its value parameters. <code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE()</span></code> supports that and can be
viewed as an extension to <code class="docutils literal notranslate"><span class="pre">ACTION()</span></code> and <code class="docutils literal notranslate"><span class="pre">ACTION_P*()</span></code>.</p>
<p>The syntax:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_TEMPLATE</span><span class="p">(</span><span class="n">ActionName</span><span class="p">,</span>
                <span class="n">HAS_m_TEMPLATE_PARAMS</span><span class="p">(</span><span class="n">kind1</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">kind_m</span><span class="p">,</span> <span class="n">name_m</span><span class="p">),</span>
                <span class="n">AND_n_VALUE_PARAMS</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">p_n</span><span class="p">))</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>defines an action template that takes <em>m</em> explicit template parameters and <em>n</em>
value parameters, where <em>m</em> is in [1, 10] and <em>n</em> is in [0, 10]. <code class="docutils literal notranslate"><span class="pre">name_i</span></code> is the
name of the <em>i</em>-th template parameter, and <code class="docutils literal notranslate"><span class="pre">kind_i</span></code> specifies whether it’s a
<code class="docutils literal notranslate"><span class="pre">typename</span></code>, an integral constant, or a template. <code class="docutils literal notranslate"><span class="pre">p_i</span></code> is the name of the <em>i</em>-th
value parameter.</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// DuplicateArg&lt;k, T&gt;(output) converts the k-th argument of the mock</span>
<span class="c1">// function to type T and copies it to *output.</span>
<span class="n">ACTION_TEMPLATE</span><span class="p">(</span><span class="n">DuplicateArg</span><span class="p">,</span>
                <span class="c1">// Note the comma between int and k:</span>
                <span class="n">HAS_2_TEMPLATE_PARAMS</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span>
                <span class="n">AND_1_VALUE_PARAMS</span><span class="p">(</span><span class="n">output</span><span class="p">))</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To create an instance of an action template, write:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ActionName</span><span class="o">&lt;</span><span class="n">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">t_m</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">v_n</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">t</span></code>s are the template arguments and the <code class="docutils literal notranslate"><span class="pre">v</span></code>s are the value arguments.
The value argument types are inferred by the compiler. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span> <span class="n">Foo</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DuplicateArg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">));</span>
</pre></div>
</div>
<p>If you want to explicitly specify the value argument types, you can provide
additional template arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ActionName</span><span class="o">&lt;</span><span class="n">t1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">t_m</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">u_k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">v_n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">u_i</span></code> is the desired type of <code class="docutils literal notranslate"><span class="pre">v_i</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE</span></code> and <code class="docutils literal notranslate"><span class="pre">ACTION</span></code>/<code class="docutils literal notranslate"><span class="pre">ACTION_P*</span></code> can be overloaded on the number of
value parameters, but not on the number of template parameters. Without the
restriction, the meaning of the following is unclear:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">OverloadedAction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>Are we using a single-template-parameter action where <code class="docutils literal notranslate"><span class="pre">bool</span></code> refers to the type
of <code class="docutils literal notranslate"><span class="pre">x</span></code>, or a two-template-parameter action where the compiler is asked to infer
the type of <code class="docutils literal notranslate"><span class="pre">x</span></code>?</p>
</div>
<div class="section" id="using-the-action-object-s-type">
<h3>Using the ACTION Object’s Type<a class="headerlink" href="#using-the-action-object-s-type" title="Permalink to this headline">¶</a></h3>
<p>If you are writing a function that returns an <code class="docutils literal notranslate"><span class="pre">ACTION</span></code> object, you’ll need to
know its type. The type depends on the macro used to define the action and the
parameter types. The rule is relatively simple:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Given Definition</th>
<th>Expression</th>
<th>Has Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ACTION(Foo)</code></td>
<td><code>Foo()</code></td>
<td><code>FooAction</code></td>
</tr>
<tr>
<td><code>ACTION_TEMPLATE(Foo, HAS_m_TEMPLATE_PARAMS(...), AND_0_VALUE_PARAMS())</code></td>
<td><code>Foo&lt;t1, ..., t_m&gt;()</code></td>
<td><code>FooAction&lt;t1, ..., t_m&gt;</code></td>
</tr>
<tr>
<td><code>ACTION_P(Bar, param)</code></td>
<td><code>Bar(int_value)</code></td>
<td><code>BarActionP&lt;int&gt;</code></td>
</tr>
<tr>
<td><code>ACTION_TEMPLATE(Bar, HAS_m_TEMPLATE_PARAMS(...), AND_1_VALUE_PARAMS(p1))</code></td>
<td><code>Bar&lt;t1, ..., t_m&gt;(int_value)</code></td>
<td><code>BarActionP&lt;t1, ..., t_m, int&gt;</code></td>
</tr>
<tr>
<td><code>ACTION_P2(Baz, p1, p2)</code></td>
<td><code>Baz(bool_value, int_value)</code></td>
<td><code>BazActionP2&lt;bool, int&gt;</code></td>
</tr>
<tr>
<td><code>ACTION_TEMPLATE(Baz, HAS_m_TEMPLATE_PARAMS(...), AND_2_VALUE_PARAMS(p1, p2))</code></td>
<td><code>Baz&lt;t1, ..., t_m&gt;(bool_value, int_value)</code></td>
<td><code>BazActionP2&lt;t1, ..., t_m, bool, int&gt;</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table><p>Note that we have to pick different suffixes (<code class="docutils literal notranslate"><span class="pre">Action</span></code>, <code class="docutils literal notranslate"><span class="pre">ActionP</span></code>, <code class="docutils literal notranslate"><span class="pre">ActionP2</span></code>,
and etc) for actions with different numbers of value parameters, or the action
definitions cannot be overloaded on the number of them.</p>
</div>
<div class="section" id="writing-new-monomorphic-actions-newmonoactions">
<h3>Writing New Monomorphic Actions {#NewMonoActions}<a class="headerlink" href="#writing-new-monomorphic-actions-newmonoactions" title="Permalink to this headline">¶</a></h3>
<p>While the <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> macros are very convenient, sometimes they are
inappropriate. For example, despite the tricks shown in the previous recipes,
they don’t let you directly specify the types of the mock function arguments and
the action parameters, which in general leads to unoptimized compiler error
messages that can baffle unfamiliar users. They also don’t allow overloading
actions based on parameter types without jumping through some hoops.</p>
<p>An alternative to the <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> macros is to implement
<code class="docutils literal notranslate"><span class="pre">::testing::ActionInterface&lt;F&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">F</span></code> is the type of the mock function in
which the action will be used. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ActionInterface</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ActionInterface</span><span class="p">();</span>

  <span class="c1">// Performs the action.  Result is the return type of function type</span>
  <span class="c1">// F, and ArgumentTuple is the tuple of arguments of F.</span>
  <span class="c1">//</span>

  <span class="c1">// For example, if F is int(bool, const string&amp;), then Result would</span>
  <span class="c1">// be int, and ArgumentTuple would be std::tuple&lt;bool, const string&amp;&gt;.</span>
  <span class="k">virtual</span> <span class="n">Result</span> <span class="nf">Perform</span><span class="p">(</span><span class="k">const</span> <span class="n">ArgumentTuple</span><span class="o">&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ActionInterface</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakeAction</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="nf">IncrementMethod</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">IncrementArgumentAction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ActionInterface</span><span class="o">&lt;</span><span class="n">IncrementMethod</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">Perform</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>  <span class="c1">// Grabs the first argument.</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">Action</span><span class="o">&lt;</span><span class="n">IncrementMethod</span><span class="o">&gt;</span> <span class="n">IncrementArgument</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MakeAction</span><span class="p">(</span><span class="k">new</span> <span class="n">IncrementArgumentAction</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">Baz</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
      <span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">IncrementArgument</span><span class="p">());</span>

  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">Baz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// Should return 5 and change n to 6.</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-new-polymorphic-actions-newpolyactions">
<h3>Writing New Polymorphic Actions {#NewPolyActions}<a class="headerlink" href="#writing-new-polymorphic-actions-newpolyactions" title="Permalink to this headline">¶</a></h3>
<p>The previous recipe showed you how to define your own action. This is all good,
except that you need to know the type of the function in which the action will
be used. Sometimes that can be a problem. For example, if you want to use the
action in functions with <em>different</em> types (e.g. like <code class="docutils literal notranslate"><span class="pre">Return()</span></code> and
<code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code>).</p>
<p>If an action can be used in several types of mock functions, we say it’s
<em>polymorphic</em>. The <code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code> function template makes it easy to
define such an action:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">testing</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Impl</span><span class="o">&gt;</span>
<span class="n">PolymorphicAction</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">MakePolymorphicAction</span><span class="p">(</span><span class="k">const</span> <span class="n">Impl</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">);</span>
<span class="p">}</span>  <span class="c1">// namespace testing</span>
</pre></div>
</div>
<p>As an example, let’s define an action that returns the second argument in the
mock function’s argument list. The first step is to define an implementation
class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ReturnSecondArgumentAction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Result</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ArgumentTuple</span><span class="o">&gt;</span>
  <span class="n">Result</span> <span class="n">Perform</span><span class="p">(</span><span class="k">const</span> <span class="n">ArgumentTuple</span><span class="o">&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// To get the i-th (0-based) argument, use std::get(args).</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This implementation class does <em>not</em> need to inherit from any particular class.
What matters is that it must have a <code class="docutils literal notranslate"><span class="pre">Perform()</span></code> method template. This method
template takes the mock function’s arguments as a tuple in a <strong>single</strong>
argument, and returns the result of the action. It can be either <code class="docutils literal notranslate"><span class="pre">const</span></code> or not,
but must be invocable with exactly one template argument, which is the result
type. In other words, you must be able to call <code class="docutils literal notranslate"><span class="pre">Perform&lt;R&gt;(args)</span></code> where <code class="docutils literal notranslate"><span class="pre">R</span></code> is
the mock function’s return type and <code class="docutils literal notranslate"><span class="pre">args</span></code> is its arguments in a tuple.</p>
<p>Next, we use <code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code> to turn an instance of the implementation
class into the polymorphic action we need. It will be convenient to have a
wrapper for this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakePolymorphicAction</span><span class="p">;</span>
<span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PolymorphicAction</span><span class="p">;</span>

<span class="n">PolymorphicAction</span><span class="o">&lt;</span><span class="n">ReturnSecondArgumentAction</span><span class="o">&gt;</span> <span class="n">ReturnSecondArgument</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MakePolymorphicAction</span><span class="p">(</span><span class="n">ReturnSecondArgumentAction</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, you can use this polymorphic action the same way you use the built-in ones:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MockFoo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">,</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
  <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str2</span><span class="p">),</span>
              <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

  <span class="p">...</span>
  <span class="n">MockFoo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThis</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnSecondArgument</span><span class="p">());</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">DoThat</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnSecondArgument</span><span class="p">());</span>
  <span class="p">...</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// Will return 5.</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Hi&quot;</span><span class="p">,</span> <span class="s">&quot;Bye&quot;</span><span class="p">);</span>  <span class="c1">// Will return &quot;Hi&quot;.</span>
</pre></div>
</div>
</div>
<div class="section" id="teaching-gmock-how-to-print-your-values">
<h3>Teaching gMock How to Print Your Values<a class="headerlink" href="#teaching-gmock-how-to-print-your-values" title="Permalink to this headline">¶</a></h3>
<p>When an uninteresting or unexpected call occurs, gMock prints the argument
values and the stack trace to help you debug. Assertion macros like
<code class="docutils literal notranslate"><span class="pre">EXPECT_THAT</span></code> and <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code> also print the values in question when the
assertion fails. gMock and googletest do this using googletest’s user-extensible
value printer.</p>
<p>This printer knows how to print built-in C++ types, native arrays, STL
containers, and any type that supports the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator. For other types, it
prints the raw bytes in the value and hopes that you the user can figure it out.
<a class="reference internal" href="advanced.html#teaching-googletest-how-to-print-your-values"><span class="std std-ref">The GoogleTest advanced guide</span></a>
explains how to extend the printer to do a better job at printing your
particular type than to dump the bytes.</p>
</div>
</div>
<div class="section" id="useful-mocks-created-using-gmock">
<h2>Useful Mocks Created Using gMock<a class="headerlink" href="#useful-mocks-created-using-gmock" title="Permalink to this headline">¶</a></h2>
<!--#include file="includes/g3_testing_LOGs.md"--><!--#include file="includes/g3_mock_callbacks.md"--><div class="section" id="mock-std-function-mockfunction">
<h3>Mock std::function {#MockFunction}<a class="headerlink" href="#mock-std-function-mockfunction" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">std::function</span></code> is a general function type introduced in C++11. It is a
preferred way of passing callbacks to new interfaces. Functions are copiable,
and are not usually passed around by pointer, which makes them tricky to mock.
But fear not - <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code> can help you with that.</p>
<p><code class="docutils literal notranslate"><span class="pre">MockFunction&lt;R(T1,</span> <span class="pre">...,</span> <span class="pre">Tn)&gt;</span></code> has a mock method <code class="docutils literal notranslate"><span class="pre">Call()</span></code> with the signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">R</span> <span class="nf">Call</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">Tn</span><span class="p">);</span>
</pre></div>
</div>
<p>It also has a <code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code> method, which creates a <code class="docutils literal notranslate"><span class="pre">std::function</span></code> proxy
forwarding to Call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">Tn</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">AsStdFunction</span><span class="p">();</span>
</pre></div>
</div>
<p>To use <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code>, first create <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code> object and set up
expectations on its <code class="docutils literal notranslate"><span class="pre">Call</span></code> method. Then pass proxy obtained from
<code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code> to the code you are testing. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span> <span class="n">RunsCallbackWithBarArgument</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1. Create a mock object.</span>
  <span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mock_function</span><span class="p">;</span>

  <span class="c1">// 2. Set expectations on Call() method.</span>
  <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_function</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

  <span class="c1">// 3. Exercise code that uses std::function.</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">mock_function</span><span class="p">.</span><span class="n">AsStdFunction</span><span class="p">());</span>
  <span class="c1">// Foo&#39;s signature can be either of:</span>
  <span class="c1">// void Foo(const std::function&lt;int(string)&gt;&amp; fun);</span>
  <span class="c1">// void Foo(std::function&lt;int(string)&gt; fun);</span>

  <span class="c1">// 4. All expectations will be verified when mock_function</span>
  <span class="c1">//     goes out of scope and is destroyed.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Remember that function objects created with <code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code> are just
forwarders. If you create multiple of them, they will share the same set of
expectations.</p>
<p>Although <code class="docutils literal notranslate"><span class="pre">std::function</span></code> supports unlimited number of arguments, <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code>
implementation is limited to ten. If you ever hit that limit… well, your
callback has bigger problems than being mockable. :-)</p>
</div>
</div>
</div>


                        
                    </div>
                </div>
            </div>
        </div>
    </div>    


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/clipboard.min.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  
    <div class="footer" role="contentinfo">
        <div class="container">
            &#169; Copyright bladedisc-dev@list.alibaba-inc.com.
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.
        </div>
    </div>  

</body>
</html>